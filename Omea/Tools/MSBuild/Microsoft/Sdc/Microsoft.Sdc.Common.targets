<?xml version="1.0" encoding="utf-8"?>
<!--
  <copyright company="JetBrains">
  Copyright © 2003-2008 JetBrains s.r.o.
  You may distribute under the terms of the GNU General Public License, as published by the Free Software Foundation, version 2 (see License.txt in the repository root folder).
  </copyright>
-->
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
	<!-- Global Todos
        Review use of File.GetFiles and replace with CreateItem
        Get around to removing any other execs       
    -->
	<!-- Override these properties (in build.proj) to insert custom targets before key events -->
	<PropertyGroup>
		<StartDependsOn />
		<BuildSolutionsDependsOn />
		<CleanSolutionDependsOn />
		<FxCopDependsOn />
		<InstallServicesDependsOn />
		<StyleCopDependsOn />
		<NDocDependsOn />
		<TestsDependsOn />
		<DatabaseDependencies />
		<TestScriptDependencies />
		<EndDependsOn />
		<CompleteEmailDependsOn />
		<CreateDropDependsOn>BeforeCreateDrop;CoreCreateDrop;AfterCreateDrop</CreateDropDependsOn>
	</PropertyGroup>
	<!-- The following paths should not be changed, they are used to shorten syntax througout this targets file -->
	<PropertyGroup>
		<!-- all relative paths are taken from buildpath rather than msbuildprojectDirectory, this is so we can greater control and not be dependant on the 
         location from which msbuild was launched -->
		<BuildPath Condition="'$(BuildPath)' == ''">$(MSBuildProjectDirectory)</BuildPath>
		<SolutionsPath>$(BuildPath)\..\Solutions</SolutionsPath>
		<ToolsPath>$(BuildPath)\Tools\</ToolsPath>
		<VersionXmlFile>$(BuildPath)\Versioning\VersionNumber.exe.config</VersionXmlFile>
		<FrameworkPath>$(BuildPath)\bin</FrameworkPath>
		<StopOnTestError Condition="'$(StopOnTestError)'==''">true</StopOnTestError>
	</PropertyGroup>
	<!-- Email related properties. -->
	<PropertyGroup>
		<!-- Addresses in the MailError list get emails when things have gone wrong. YOU SHOULD override this -->
		<MailError></MailError>
		<!-- Addresses in the MailTo list will always receive all emails. YOU SHOULD override this -->
		<MailTo>gilesk@microsoft.com</MailTo>
		<!-- The address that build emails appear from. YOU SHOULD override this -->
		<MailFrom>SdgBuild@microsoft.com</MailFrom>
		<!-- suffix to add to depot user names to get their email addresses. YOU SHOULD override this -->
		<MailSuffix>@microsoft.com</MailSuffix>
		<!-- The machine name of an smtp relay. YOU SHOULD override this -->
		<SmtpServer>smtphost</SmtpServer>
		<!-- set to true to send emails. If FALSE no emails will be sent at all -->
		<Email Condition=" '$(Email)' == '' ">true</Email>
		<!-- If true and emails cannot be sent then builds continue otherwise they abandon -->
		<ContinueBuildOnEmailError Condition="'$(ContinueBuildOnEmailError)'==''">false</ContinueBuildOnEmailError>
		<!-- When automated build runs, send emails to all alias that have checked in since the last build -->
		<MailToChangeList Condition="'$(MailToChangeList)' == ''">true</MailToChangeList>
		<!-- list of users to receive code coverage emails -->
		<CodeCoverageMailTo Condition=" '$(CodeCoverageMailTo)' == '' ">$(MailTo)</CodeCoverageMailTo>
	</PropertyGroup>
	<PropertyGroup>
		<!-- Version number of the Solutions Build Framework (only used in emails currently) DO NOT override-->
		<SDGBuildFrameworkVersion>2.0.060327</SDGBuildFrameworkVersion>
		<!-- Cause Daily Build to branch the depot, keeping a snapshot of the source tree at the time of build
         This property is ususally set to true by the scheduled script that fires Daily Build -->
		<CreateBranch Condition="'$(CreateBranch)' == ''">false</CreateBranch>
		<!-- If set to true, stylecop looks for csproj files and analyses the cs files that these refer to
         If false it simply analyzes all cs files it finds -->
		<StyleCopUseVSBuildFiles Condition="'$(StyleCopUseVSBuildFiles)' == ''">false</StyleCopUseVSBuildFiles>
		<!-- Set this to true to have sdrepgen build the release notes -->
		<CreateReleaseNotes Condition=" '$(CreateReleaseNotes)' == '' ">true</CreateReleaseNotes>
		<!-- Set to false to skip the InstalledProducts check -->
		<CheckInstalledProducts Condition="'$(CheckInstalledProducts)'==''">false</CheckInstalledProducts>
		<!-- Set to TRUE to force only the revision part of the build number to increase THIS MUST BE SET to true
         in a major branch to avoid version clashes with the main branch -->
		<OnlyIncrementRevision Condition="'$(OnlyIncrementRevision)' == ''">false</OnlyIncrementRevision>
		<!-- Product Name used in release Drops, emails etc. YOU SHOULD override this -->
		<ProductName Condition="'$(ProductName)' == ''">Please Override Product Name</ProductName>
		<!-- Path to root of product from root of the depot (usually the same as ProductName but with leading and trailing slash) -->
		<ProductDepotName Condition="'$(ProductDepotName)' == ''">/$(ProductName)/</ProductDepotName>
		<!-- Name of root folder for drops (usually the same as ProductName) -->
		<ProductDropName Condition="'$(ProductDropName)' == ''">$(ProductName)</ProductDropName>
		<VSSProductDepotName Condition="'$(VSSProductDepotName)' == ''">/$(ProductName)/</VSSProductDepotName>
		<!-- Name of build folder -->
		<BuildFolderName Condition="'$(BuildFolderName)' == ''">Build</BuildFolderName>
		<!-- if set to true then create a zip od the drop folder and put it in the root of drop folder -->
		<CreateDropZip Condition="'$(CreateDropZip)' == ''">true</CreateDropZip>
		<!-- culture of the build box on which this script runs -->
		<Culture Condition="'$(Culture)' == ''">en-GB</Culture>
		<!-- default value for this property is set to be SD. Current supported values are SD and VSS -->
		<SourceControl Condition="'$(SourceControl)' == ''">SD</SourceControl>
		<!-- Account under which automated builds run. YOU SHOULD override this.
         Checkins from this account are ignored when deciding to launch a buddy build -->
		<BuildUser Condition="'$(BuildUser)' == ''">Build</BuildUser>
		<!-- Controls whether to run tests on a virtual machine -->
		<TestVirtualMachine Condition="'$(TestVirtualMachine)' == ''">true</TestVirtualMachine>
		<!-- Usually the Main Branch is under root\Main\Src where Main is used for Major Branches and Src for Minor Branches
         If you have no need for Minor branches and dont wwant the extra level of subfolders in your source tree
         override this value to be / -->
		<MinorBranchFolder Condition="'$(MinorBranchFolder)' == ''">Src</MinorBranchFolder>
	</PropertyGroup>
	<Import Project="SourceControl\TFS.targets" Condition="'$(SourceControl)'=='TFS'" />
	<Import Project="SourceControl\SD.targets" Condition="'$(SourceControl)'=='SD'" />
	<Import Project="SourceControl\VSS.targets" Condition="'$(SourceControl)'=='VSS'" />
	<ItemGroup>
		<!-- IgnoreBuildChanges is useful for testing changes while working on build files  -->
		<BuildFiles Condition="'$(IgnoreBuildChanges)' != 'true'" Include="   $(BuildPath)\bin\*;&#xD;&#xA;                            $(BuildPath)\*.proj;&#xD;&#xA;                            $(BuildPath)\*.properties;" />
		<SslCerts Include="   $(BuildPath)\SSL_Certs\*" />
	</ItemGroup>
	<PropertyGroup Condition="'$(BuildType)' == 'Daily'">
		<RunCodeCoverage Condition="'$(RunCodeCoverage)'==''">true</RunCodeCoverage>
	</PropertyGroup>
	<PropertyGroup Condition="'$(BuildType)' == 'Continuous'">
		<RunCodeCoverage Condition="'$(RunCodeCoverage)'==''">true</RunCodeCoverage>
	</PropertyGroup>
	<Import Project="Microsoft.Sdc.Common.tasks" />
	<Target Name="CleanDev" Condition="'$(DoSetupDev)'=='true' OR '$(Clean)'=='true'" DependsOnTargets="&#xD;&#xA;            BuildAssemblyLists;&#xD;&#xA;            StyleCopClean;&#xD;&#xA;            DeleteTempSolutionFiles;&#xD;&#xA;            DeleteShares;&#xD;&#xA;            DeleteFolders;&#xD;&#xA;            DeleteWebVirtualDirectories;&#xD;&#xA;            DeleteFtpVirtualDirectories;&#xD;&#xA;            DeleteFtpSites;&#xD;&#xA;            FtpSitesToStop;&#xD;&#xA;            DeleteWebSites;&#xD;&#xA;            DeleteWebServiceExtensions;&#xD;&#xA;            DeleteAppPools;&#xD;&#xA;            DeletePerformanceCounters">
		<Delete Files="$(BuildPath)\Output\SetupDevMarker.txt" />
	</Target>
	<Target Name="SetupDev" Condition="'$(DoSetupDev)'=='true' OR '$(Clean)'=='true'" DependsOnTargets="&#xD;&#xA;            BuildAssemblyLists;&#xD;&#xA;            RegisterComDlls;&#xD;&#xA;            RegistryKeysToCreate;&#xD;&#xA;            RegistryKeysToSet;&#xD;&#xA;            StrongNameSkips;&#xD;&#xA;            CreateGroups;&#xD;&#xA;            CreateUsers;&#xD;&#xA;            InstallCertificates;&#xD;&#xA;            AddUsersToGroups;&#xD;&#xA;            GrantPrivileges;&#xD;&#xA;            CreateOutputFolders;&#xD;&#xA;            CreateEventSources;&#xD;&#xA;            CreatePerformanceCounters;&#xD;&#xA;            CreateAppPools;&#xD;&#xA;            CreateWebServiceExtensions;&#xD;&#xA;            CreateWebSites;&#xD;&#xA;            CreateFolders;&#xD;&#xA;            AddAcls;&#xD;&#xA;            CreateShares;&#xD;&#xA;            CreateWebVirtualDirectories;&#xD;&#xA;            UpdateWebSiteSettings;&#xD;&#xA;            CreateFtpSites;&#xD;&#xA;            CreateFtpVirtualDirectories;&#xD;&#xA;            StartFtpSites;&#xD;&#xA;            StartWebSites">
		<Touch AlwaysCreate="true" Files="$(BuildPath)\Output\SetupDevMarker.txt" />
	</Target>
	<Target Name="Dev" DependsOnTargets="&#xD;&#xA;            Start;            &#xD;&#xA;            BuildAssemblyLists;&#xD;&#xA;            DeleteOutputFiles;&#xD;&#xA;            ForceSteps;            &#xD;&#xA;            PreBuildServices;&#xD;&#xA;            SyncSourceControl;&#xD;&#xA;            CheckCSProj;&#xD;&#xA;            LoadVersion;&#xD;&#xA;            StyleCop;&#xD;&#xA;            CheckSetupDev;&#xD;&#xA;            CleanDev;&#xD;&#xA;            SetupDev;&#xD;&#xA;            DeleteAssemblyDownloadCache;&#xD;&#xA;            DeleteVSWebCache;&#xD;&#xA;            CleanSolution;&#xD;&#xA;            BuildSolutions;&#xD;&#xA;            CopyAdditionalFiles;&#xD;&#xA;            FxCop;&#xD;&#xA;            InstallServices;&#xD;&#xA;            PreSharp;&#xD;&#xA;            CreateDatabases;&#xD;&#xA;            GrantAccessToSqlUsers;&#xD;&#xA;            AddSqlUsersToRoles;&#xD;&#xA;            Tests;&#xD;&#xA;            Summary;&#xD;&#xA;            End">
		<OnError ExecuteTargets="ErrorTarget" />
	</Target>
	<Target Name="Buddy" Condition=" '$(BuildType)' == 'Buddy' " DependsOnTargets="&#xD;&#xA;            Start;&#xD;&#xA;            LoadVersion;&#xD;&#xA;            CheckDepotForChangesContinuous;            &#xD;&#xA;            ContinueBuildBuddy">
		<OnError ExecuteTargets="ErrorTarget" />
	</Target>
	<Target Name="ContinueBuildBuddy" Condition=" '$(FilesChanged)' == 'true' " DependsOnTargets="               &#xD;&#xA;            DeleteOutputFiles; &#xD;&#xA;            ForceSteps;&#xD;&#xA;            SyncSourceControl;&#xD;&#xA;            GetUsersForChangelists;          &#xD;&#xA;            EmailStart;            &#xD;&#xA;            BuildAssemblyLists;                 &#xD;&#xA;            CheckCSProj;                                         &#xD;&#xA;            PreBuildServices;                    &#xD;&#xA;            StyleCop;                            &#xD;&#xA;            DeleteAssemblyDownloadCache;         &#xD;&#xA;            DeleteVSWebCache;         &#xD;&#xA;            CheckSetupDev;           &#xD;&#xA;            CleanDev;                                &#xD;&#xA;            SetupDev;                        &#xD;&#xA;            CleanSolution;                   &#xD;&#xA;            BuildSolutions;                  &#xD;&#xA;            CopyAdditionalFiles;             &#xD;&#xA;            StrongNameAssemblies;&#xD;&#xA;            FxCop;&#xD;&#xA;            InstallServices;&#xD;&#xA;            PreSharp;&#xD;&#xA;            CreateDatabases;&#xD;&#xA;            GrantAccessToSqlUsers;&#xD;&#xA;            AddSqlUsersToRoles;&#xD;&#xA;            Tests;  &#xD;&#xA;            LabelLatest;&#xD;&#xA;            Summary;&#xD;&#xA;            BuildReport;&#xD;&#xA;            EmailComplete;&#xD;&#xA;            End;&#xD;&#xA;            ">
		<OnError ExecuteTargets="EmailError" />
	</Target>
	<!-- we run Continuous as a heavyweight Build , override target accordingly -->
	<Target Name="Continuous" Condition=" '$(BuildType)' == 'Continuous' " DependsOnTargets="&#xD;&#xA;            Start;&#xD;&#xA;            LoadVersion;&#xD;&#xA;            CheckDepotForChangesContinuous;            &#xD;&#xA;            ContinueBuildContinuous">
		<OnError ExecuteTargets="ErrorTarget" />
	</Target>
	<Target Name="ContinueBuildContinuous" Condition=" '$(FilesChanged)' == 'true' " DependsOnTargets="                       &#xD;&#xA;            DeleteOutputFiles;  &#xD;&#xA;            ForceSteps;                        &#xD;&#xA;            SyncSourceControl;                 &#xD;&#xA;            GetUsersForChangelists;            &#xD;&#xA;            EmailStart;                                    &#xD;&#xA;            CheckProductInstallation;                  &#xD;&#xA;            CheckComponentInstallation;             &#xD;&#xA;            BuildAssemblyLists;                 &#xD;&#xA;            StrongNameSkips;                          &#xD;&#xA;            CheckCSProj;                             &#xD;&#xA;            UpdateVersionNumber;&#xD;&#xA;            PreBuildServices;                     &#xD;&#xA;            BranchDepot;                       &#xD;&#xA;            StyleCopClean;                              &#xD;&#xA;            StyleCop;                                       &#xD;&#xA;            CreateOutputFolders;                                &#xD;&#xA;            DeleteTempSolutionFiles;                 &#xD;&#xA;            DeleteAssemblyDownloadCache;                      &#xD;&#xA;            DeleteVSWebCache;                      &#xD;&#xA;            CleanSolution;                              &#xD;&#xA;            BuildSolutions;                              &#xD;&#xA;            CopyAdditionalFiles;               &#xD;&#xA;            StrongNameAssemblies;              &#xD;&#xA;            FxCop;                                  &#xD;&#xA;            PreSharp;                          &#xD;&#xA;            BuildInstallers;                   &#xD;&#xA;            Deploy;                             &#xD;&#xA;            Tests;                             &#xD;&#xA;            NDoc;                              &#xD;&#xA;            BuildReport;                        &#xD;&#xA;            ReleaseNotes;                        &#xD;&#xA;            CreateDrop;                        &#xD;&#xA;            EmailComplete;&#xD;&#xA;            LabelLatest;                          &#xD;&#xA;            VirtualServers;                        &#xD;&#xA;            End   &#xD;&#xA;            ">
		<OnError ExecuteTargets="EmailError" />
	</Target>
	<!-- Todo Code coverage could be an alternative build type run independent of daily -->
	<Target Name="Daily" DependsOnTargets="&#xD;&#xA;            Start;&#xD;&#xA;            LoadVersion;&#xD;&#xA;            CheckDepotForChangesContinuous;&#xD;&#xA;            ContinueDailyBuild;&#xD;&#xA;            EmailAbandon">
		<OnError ExecuteTargets="ErrorTarget" />
	</Target>
	<Target Name="ContinueDailyBuild" Condition=" '$(FilesChanged)' == 'true' " DependsOnTargets="                         &#xD;&#xA;            DeleteOutputFiles; &#xD;&#xA;            ForceSteps;                        &#xD;&#xA;            SyncSourceControl;                 &#xD;&#xA;            GetUsersForChangelists;            &#xD;&#xA;            EmailStart;                                    &#xD;&#xA;            CheckProductInstallation;                  &#xD;&#xA;            CheckComponentInstallation;             &#xD;&#xA;            BuildAssemblyLists;                 &#xD;&#xA;            StrongNameSkips;                          &#xD;&#xA;            CheckCSProj;                             &#xD;&#xA;            UpdateVersionNumber;&#xD;&#xA;            PreBuildServices;                     &#xD;&#xA;            BranchDepot;                       &#xD;&#xA;            StyleCopClean;                              &#xD;&#xA;            StyleCop;                                       &#xD;&#xA;            CreateOutputFolders;                                &#xD;&#xA;            DeleteTempSolutionFiles;                 &#xD;&#xA;            DeleteAssemblyDownloadCache;                      &#xD;&#xA;            DeleteVSWebCache;                      &#xD;&#xA;            CleanSolution;                              &#xD;&#xA;            BuildSolutions;                              &#xD;&#xA;            CopyAdditionalFiles;               &#xD;&#xA;            StrongNameAssemblies;              &#xD;&#xA;            FxCop;                                  &#xD;&#xA;            PreSharp;                          &#xD;&#xA;            BuildInstallers;                   &#xD;&#xA;            Deploy;                             &#xD;&#xA;            Tests;                             &#xD;&#xA;            NDoc;                              &#xD;&#xA;            BuildReport;                        &#xD;&#xA;            ReleaseNotes;                        &#xD;&#xA;            CreateDrop;                        &#xD;&#xA;            EmailComplete;&#xD;&#xA;            LabelLatest;                          &#xD;&#xA;            VirtualServers;                        &#xD;&#xA;            End">
		<OnError ExecuteTargets="EmailError" />
	</Target>
	<Target Name="AfterCreateDrop" />
	<Target Name="BeforeCreateDrop" />
	<!-- All the targets after here are in alphabetical order -->
	<Target Name="AddAcls" Condition=" '@(FoldersToAcl)' != '' ">
		<Security.AddAcl Path="%(FoldersToAcl.Identity)" ApplyTo="%(FoldersToAcl.ApplyTo)" UserOrGroup="%(FoldersToAcl.UserOrGroup)" AccessType="%(FoldersToAcl.AccessType)" />
	</Target>
	<Target Name="AddSqlUsersToRoles" Condition="'@(SqlUsersToAddToRole)' != '' AND '$(DatabaseBuilt)'=='true'">
		<Sql.Role.AddUser ServerName="%(SqlUsersToAddToRole.ServerName)" DatabaseName="%(SqlUsersToAddToRole.DatabaseName)" UserName="%(SqlUsersToAddToRole.Identity)" RoleName="%(SqlUsersToAddToRole.RoleName)" />
	</Target>
	<Target Name="AddUsersToGroups">
		<ActiveDirectory.Group.AddUser Condition="'%(Users.Group)' != '' " EnsureUserIsInGroup="true" UserName="%(Users.Identity)" GroupName="%(Users.Group)" />
	</Target>
	<Target Name="BranchDepot" Condition="'$(CreateBranch)'=='true'" DependsOnTargets="LoadVersion">
		<CallTarget Targets="BranchDepot_SourceControl" />
	</Target>
	<Target Name="BuildAssemblyLists">
		<!-- create individualy named properties for solution metadata so we can extract it when creating AllAssembliesFull (below)-->
		<!-- Note that AlternateName must be supplied if the solution name contains '.'-->
		<CreateProperty Value="%(Solutions.VSVersion)" Condition="'%(Solutions.AlternateName)'!=''">
			<Output TaskParameter="Value" PropertyName="%(Solutions.AlternateName)SolutionVSVersion" />
		</CreateProperty>
		<CreateProperty Value="%(Solutions.VSVersion)" Condition="'%(Solutions.AlternateName)'==''">
			<Output TaskParameter="Value" PropertyName="%(Solutions.Identity)SolutionVSVersion" />
		</CreateProperty>
		<CreateItem Include="@(AllAssemblies-&gt;'$(SolutionsPath)\%(SolutionName)Assemblies\%(Identity)')">
			<Output TaskParameter="Include" ItemName="AllAssembliesTemp" />
		</CreateItem>
		<CreateItem Include="@(AllAssembliesTemp)" AdditionalMetadata="CSProjFile=$(SolutionsPath)\%(AllAssembliesTemp.SolutionName)$(SolutionFolderSuffix)\%(AllAssembliesTemp.ProjectName)\%(AllAssembliesTemp.ProjectName).csproj;&#xD;&#xA;                                DocumentationFile=%(AllAssembliesTemp.Filename).xml;&#xD;&#xA;                                VSVersion=$(%(AllAssembliesTemp.SolutionName)SolutionVSVersion)">
			<Output TaskParameter="Include" ItemName="AllAssembliesFull" />
		</CreateItem>
		<CreateItem Condition=" '%(AllAssembliesFull.FxCop)' == 'true' " Include="@(AllAssembliesFull)">
			<Output TaskParameter="Include" ItemName="FxCopAssemblies" />
		</CreateItem>
		<CreateItem Condition=" '%(AllAssembliesFull.PreSharp)' == 'true' " Include="@(AllAssembliesFull)">
			<Output TaskParameter="Include" ItemName="PreSharpAssemblies" />
		</CreateItem>
		<CreateItem Condition=" '%(AllAssembliesFull.NDoc)' == 'true' " Include="@(AllAssembliesFull)">
			<Output TaskParameter="Include" ItemName="NDocAssemblies" />
		</CreateItem>
		<CreateItem Condition=" '%(AllAssembliesFull.Strongname)' == 'true' " Include="@(AllAssembliesFull)">
			<Output TaskParameter="Include" ItemName="SnAssemblies" />
		</CreateItem>
		<CreateItem Condition=" '%(AllAssembliesFull.NUnit)' == 'true' " Include="@(AllAssembliesFull)">
			<Output TaskParameter="Include" ItemName="NUnitAssemblies" />
		</CreateItem>
		<File.GetFiles Recursive="true" Path="$(SolutionsPath)\%(AllAssembliesFull.SolutionName)$(SolutionFolderSuffix)\%(AllAssembliesFull.ProjectName)" Masks="*.cs">
			<Output TaskParameter="OutputFiles" ItemName="AllCSFiles"></Output>
		</File.GetFiles>
		<File.GetFiles Recursive="true" Path="$(SolutionsPath)\%(AllAssembliesFull.SolutionName)$(SolutionFolderSuffix)\%(AllAssembliesFull.ProjectName)" Masks="*.cs;*.csproj;*.cpp;*.h;*.proj;$(AdditionalMasksForAllSourceFilesForBinaries)">
			<Output TaskParameter="OutputFiles" ItemName="AllSourceFilesForBinaries"></Output>
		</File.GetFiles>
		<Message Text="&#xA;Solution Items: &#xA; @(%(Solutions.Identity)Solution-&gt;'%(Identity) VSVersion = %(VSVersion)','&#xA;')" Importance="Low" />
		<Message Text="&#xA;AllAssemblies.Identity: &#xA; @(AllAssemblies-&gt;'%(Identity)','&#xA;')" Importance="Low" />
		<Message Text="&#xA;AllAssembliesFull.Identity: &#xA; @(AllAssembliesFull-&gt;'%(Identity)','&#xA;')" Importance="Low" />
		<Message Text="&#xA;AllAssembliesFull.VSVersion: &#xA; @(AllAssembliesFull-&gt;'%(VSVersion)','&#xA;')" Importance="Low" />
		<Message Text="&#xA;AllAssembliesFull.FxCop: &#xA; @(AllAssembliesFull-&gt;'%(FxCop)','&#xA;')" Importance="Low" />
		<Message Text="&#xA;AllAssembliesFull.SolutionName: &#xA; @(AllAssembliesFull-&gt;'%(SolutionName)','&#xA;')" Importance="Low" />
		<Message Text="&#xA;AllAssembliesFull.CSProjFile:&#xA; @(AllAssembliesFull-&gt;'%(CSProjFile)','&#xA;')" Importance="Low" />
		<Message Text="&#xA;AllAssembliesFull.DocumentationFile: &#xA; @(AllAssembliesFull-&gt;'%(DocumentationFile)','&#xA;')" Importance="Low" />
		<Message Text="&#xA;AllAssembliesFull: &#xA; @(AllAssembliesFull-&gt;'%(FullPath)','&#xA;')" Importance="Low" />
		<Message Text="&#xA;FxCop Assemblies: &#xA; @(FxCopAssemblies-&gt;'%(FullPath)','&#xA;')" Importance="Low" />
		<Message Text="&#xA;PreSharp Assemblies: &#xA; @(PreSharpAssemblies-&gt;'%(FullPath)','&#xA;')" Importance="Low" />
		<Message Text="&#xA;NDoc Assemblies: &#xA; @(NDocAssemblies-&gt;'%(FullPath)','&#xA;')" Importance="Low" />
		<Message Text="&#xA;Nunit Assemblies: &#xA; @(NUnitAssemblies-&gt;'%(FullPath)','&#xA;')" Importance="Low" />
		<Message Text="&#xA;MsTest Assemblies: &#xA; @(MsTestAssemblies-&gt;'%(FullPath)','&#xA;')" Importance="Low" />
		<Message Text="&#xA;Strong Name Assemblies: &#xA; @(SnAssemblies-&gt;'%(FullPath)','&#xA;')" Importance="Low" />
		<Message Text="&#xA;Additional Masks For All Source Files For Binaries: &#xA; $(AdditionalMasksForAllSourceFilesForBinaries)" Importance="Low" />
		<Message Text="&#xA;All Source Files: &#xA; @(AllSourceFilesForBinaries-&gt;'%(FullPath)','&#xA;')" Importance="Low" />
		<Message Text="&#xA;AllAssembliesFull.MaxFxCopErrors: &#xA; @(AllAssembliesFull-&gt;'%(MaxFxCopErrors)','&#xA;')" Importance="Low" />
	</Target>
	<Target Name="BuildFragments" Condition="'@(WixFragment)'!=''" DependsOnTargets="ResourceFragments">
		<File.GetFiles Recursive="%(WixFragment.Recursive)" Path="%(WixFragment.Path)" Include="%(WixFragment.Include)" Exclude="%(WixFragment.Exclude)" Masks="%(WixFragment.Masks)">
			<Output TaskParameter="OutputFiles" ItemName="%(WixFragment.ItemListName)"></Output>
		</File.GetFiles>
		<Wix.Fragment RootPath="%(WixFragment.Path)" SourceFiles="@(%(WixFragment.ItemListName))" DirectoryRef="%(WixFragment.DirectoryRef)" OutputPath="%(WixFragment.Identity)">
			<Output TaskParameter="Components" ItemName="%(WixFragment.ComponentItemListName)" />
		</Wix.Fragment>
		<!-- Modify the path to all other binaries in the common content to be in the appropriate Assemblies  folder 
         (since this is where we do strong naming) -->
		<File.RegEx Path="%(WixPathModify.Identity)" Condition="'%(WixPathModify.Identity)'!=''" RegularExpression="%(WixPathModify.Expression)" NewValue="%(WixPathModify.NewValue)" />
		<!--
        <File.GetFiles Recursive="%(WixFragment.Recursive)" 
                    Path="%(WixFragment.Path)" 
                    Include="%(WixFragment.Include)"
                    Exclude="%(WixFragment.Exclude)"
                    Masks="%(WixFragment.Masks)">
            <Output TaskParameter="OutputFiles" ItemName="%(WixFragment.ItemListName)"></Output>
        </File.GetFiles>

        <Wix.Fragment RootPath="%(WixFragment.Path)"
                    SourceFiles="@(%(WixFragment.ItemListName))"
                    DirectoryRef="%(WixFragment.DirectoryRef)"
                    OutputPath="%(WixFragment.Identity)" >
            <Output TaskParameter="Components" ItemName="AllComponents"/>
        </Wix.Fragment>

        <File.RegEx Path="%(WixPathModify.Identity)"
                        RegularExpression="%(WixPathModify.Expression)" 
                        NewValue="%(WixPathModify.NewValue)" />
-->
	</Target>
	<Target Name="BuildFragmentComponentLists">
		<!-- I believe that the following should be all that is required to add the componentlist fragments 
         However MSBuild gets confused so I've split it into two statements          
          
    <CreateProperty
       Value="@(%(ComponentRef.ComponentListName)->'&lt;ComponentRef Id=&quot;%(Identity)&quot; /&gt;','&#x0a;')">
      <Output 
          TaskParameter="ValueSetByTask" PropertyName="%(AllComponents.ComponentListName)Transformed"/>
    </CreateProperty>   
    -->
		<CreateItem Include="@(%(ComponentRef.ComponentListName))" AdditionalMetadata="ComponentListName=%(ComponentRef.ComponentListName)">
			<Output TaskParameter="Include" ItemName="AllComponents" />
		</CreateItem>
		<CreateProperty Value="@(AllComponents-&gt;'&lt;ComponentRef Id=&quot;%(Identity)&quot; /&gt;','&#xA;')">
			<Output TaskParameter="ValueSetByTask" PropertyName="%(AllComponents.ComponentListName)Transformed" />
		</CreateProperty>
		<Message Text="Component References item list...   &#xD;&#xA;                        Path=%(ComponentRef.Identity)    &#xD;&#xA;                        RegularExpression=%(ComponentRef.RegularExpression)&#xD;&#xA;                        ComponentListName=%(ComponentRef.ComponentListName)&#xD;&#xA;                        NewValue=$(%(ComponentRef.ComponentListName)Transformed)" Importance="Low" />
	</Target>
	<PropertyGroup>
		<WixSourcePath Condition=" '$(WixSourcePath)' == '' ">$(BuildPath)</WixSourcePath>
	</PropertyGroup>
	<ItemGroup Condition="'$(WixSourcePath)'!=''">
		<WixInstallerScripts Include="$(WixSourcePath)\**\*.proj" />
	</ItemGroup>
	<Target Name="BuildInstallers" DependsOnTargets="LoadVersion;ForceSteps;BuildInstallersCheck;BuildInstallersInternal" />
	<Target Name="BuildInstallersCheck" Inputs="  &#xD;&#xA;                    @(WixInstallerScripts);&#xD;&#xA;                    @(WixSourceFiles-&gt;'%(Template)');&#xD;&#xA;                    $(BuildPath)\Output\BuildAllSolutionsMarker.txt;&#xD;&#xA;                    @(DatabaseDependencies);@(Databases)" Outputs="$(BuildPath)\Output\BuildInstallersMarker.txt">
		<!-- we use this property to control execution of BuildInstallersInternal plus all its dependencies.
             This is because MSBUILD does not allow control of dependent tragets through inputs/outputs -->
		<CreateProperty Value="true">
			<Output TaskParameter="ValueSetByTask" PropertyName="DoExecuteBuildInstallers"></Output>
		</CreateProperty>
	</Target>
	<Target Name="BuildInstallersInternal" Condition="Exists('$(PropertyDefinitionFile)') AND '$(DoExecuteBuildInstallers)'=='true' AND '@(WixSourceFiles)'!=''" DependsOnTargets="BuildFragments;BuildFragmentComponentLists;GenerateProductVersionForMSI">
		<!-- Recreate the drop folder for the new MSI files -->
		<RemoveDir Condition="Exists($(WixDropPath))" Directories="$(WixDropPath)" />
		<MakeDir Directories="$(WixDropPath)" />
		<RemoveDir Directories="$(WixIntermediatePath)\obj" />
		<MakeDir Directories="$(WixIntermediatePath)\obj" />
		<!-- Copy in files that are versioned with the MSIs -->
		<Microsoft.Build.Tasks.Copy SourceFiles="@(FilesVersionedWithMsis)" DestinationFolder="$(WixDropPath)" />
		<!-- Create a temporary property file to work with -->
		<Microsoft.Build.Tasks.Copy SourceFiles="$(PropertyDefinitionFile)" DestinationFiles="$(TempPropertyDefinitionFile)" />
		<!-- The namespace must be removed from the xml file first because the GetValue task doesn't support namespaces -->
		<File.RegEx Path="$(TempPropertyDefinitionFile)" RegularExpression="&lt;Properties xmlns=&quot;urn:sdc-microsoft-com:deployment:properties:v2.0&quot;&gt;" NewValue="&lt;Properties&gt;" />
		<!-- Get an item list of the property names -->
		<Xml.GetValue Path="$(TempPropertyDefinitionFile)" XPath="/Properties/Property/@Name">
			<Output TaskParameter="Results" ItemName="CustomActionDataList" />
		</Xml.GetValue>
		<!-- Build the Custom Action Data-->
		<CreateProperty Value="@(CustomActionDataList-&gt;'/%(Identity)=[%(Identity)]', ' ')">
			<Output TaskParameter="Value" PropertyName="CustomActionDataString" />
		</CreateProperty>
		<Message Text="Custom Action Data:$(CustomActionDataString)" />
		<!-- Create working copies of the WiX template files -->
		<Microsoft.Build.Tasks.Copy Condition="'%(WixSourceFiles.Template)'!=''" SourceFiles="%(WixSourceFiles.Template)" DestinationFiles="%(WixSourceFiles.Identity)" />
		<!-- Process the BuildPath property -->
		<Message Text="Updating BuildPath property in Wix source files..." />
		<File.RegEx Path="%(WixSourceFiles.Identity)" RegularExpression="%MSBuildProjectDirectory%" NewValue="$(BuildPath)" />
		<!-- Process the version property -->
		<Message Text="Updating Version property in Wix source files..." />
		<File.RegEx Path="%(WixSourceFiles.Identity)" RegularExpression="%ProductVersion%" NewValue="$(ProductVersionForMSI)" />
		<!-- Process CustomActionData property-->
		<Message Text="Updating CustomActionData property in Wix source files..." />
		<File.RegEx Path="%(WixSourceFiles.Identity)" RegularExpression="%EnvironmentProperties%" NewValue="$(CustomActionDataString)" />
		<!-- Create the Product Guids -->
		<Message Text="Creating product Guids..." />
		<CreateGuid Condition="'%(WixSourceFiles.GuidName)'!=''">
			<Output TaskParameter="GuidRegistryFormatString" ItemName="%(WixSourceFiles.GuidName)" />
		</CreateGuid>
		<!-- Process the Product Guids -->
		<Message Text="Updating Product Guid property in Wix source files..." />
		<File.RegEx Condition="'%(WixSourceFiles.ProductGuidRegex)'!=''" Path="%(WixSourceFiles.Identity)" RegularExpression="%(WixSourceFiles.ProductGuidRegex)" NewValue="@(%(WixSourceFiles.GuidName))" Force="true" />
		<!-- Other Components -->
		<File.RegEx Condition="'@(ComponentRef)'!=''" Path="%(ComponentRef.Identity)" RegularExpression="%(ComponentRef.RegularExpression)" NewValue="$(%(ComponentRef.ComponentListName)Transformed)" />
		<!-- Todo this target needs modifying to support multiple solutions -->
		<CreateProperty Value="%(Solutions.WixVersion)">
			<Output TaskParameter="Value" PropertyName="WixVersionNum" />
		</CreateProperty>
		<Wix.CompileMsi SourceFiles="%(WixSourceFiles.Identity)" OutputFile="%(WixSourceFiles.Intermediate)" WixPath="$(ToolsPath)Wix\$(WixVersionNum)" InformationLevel="0" WarningLevel="0" TreatWarningsAsErrors="false" />
		<Wix.LinkMsi SourceFiles="@(WixMsiFiles-&gt;'%(Intermediate)')" OutputFile="%(WixMsiFiles.Identity)" WixPath="$(ToolsPath)Wix\$(WixVersionNum)" InformationLevel="0" WarningLevel="0" TreatWarningsAsErrors="false" />
		<Touch AlwaysCreate="true" Files="$(BuildPath)\Output\BuildInstallersMarker.txt" />
	</Target>
	<Target Name="BuildReport">
		<File.Delete Files="$(BuildPath)\Output\BuildReport.xml;$(BuildPath)\Output\BuildReport.htm" />
		<!-- TODO Add this back in when the CC is working again -->
		<!-- 
        <Summary.AddToReport
            SourceFolder="$(BuildPath)\Output\Test\CodeCoverage"
            FileSpec="Report*.xml"
            ReportFile="$(BuildPath)\Output\BuildReport.xml"
            SectionGenerator="Microsoft.Sdc.Tasks.Configuration.SummaryGeneration.Generators.CodeCoverageSectionGenerator" />
        -->
		<Summary.AddToReport Condition="Exists('$(BuildPath)\Output\Test\Summary.xml')" SourceFolder="$(BuildPath)\Output\Test" FileSpec="Summary.xml" ReportFile="$(BuildPath)\Output\BuildReport.xml" SectionGenerator="Microsoft.Sdc.Tasks.Configuration.SummaryGeneration.Generators.NUnitSectionGenerator" />
		<Summary.AddToReport Condition="Exists('$(BuildPath)\Output\%(Solutions.Identity)\StyleCopErrors.xml')" SourceFolder="$(BuildPath)\Output\%(Solutions.Identity)" FileSpec="StyleCopErrors.xml" ReportFile="$(BuildPath)\Output\BuildReport.xml" SectionGenerator="Microsoft.Sdc.Tasks.Configuration.SummaryGeneration.Generators.StyleCopSummarySectionGenerator" />
		<!--
        <Summary.AddToReport
                Condition="Exists('$(BuildPath)\Output\%(Solutions.Identity).sln.$(Configuration).txt')"
                SourceFolder="$(BuildPath)\Output"
                FileSpec="%(Solutions.Identity).sln.$(Configuration).txt"
                ReportFile="$(BuildPath)\Output\BuildReport.xml"
                SectionGenerator="Microsoft.Sdc.Tasks.Configuration.SummaryGeneration.Generators.SolutionSectionGenerator" />
-->
		<Xml.XslTransform XslFile="$(BuildPath)\Xsl\BuildReport.xsl" XmlFile="$(BuildPath)\Output\BuildReport.xml" ResultFile="$(BuildPath)\Output\BuildReport.htm" />
	</Target>
	<Target Name="BuildSolutions" Condition=" '@(Solutions)' != '' " DependsOnTargets="BuildAssemblyLists;ForceSteps;$(BuildSolutionsDependsOn)" Inputs="@(AllSourceFilesForBinaries)" Outputs="$(BuildPath)\Output\%(Solutions.Identity)\BuildSolutionsMarker.txt">
		<!-- Outputs should include @(AllAssembliesFull); but this seems to always cause a build (needs further investigation)
            plus it would only be of use if someone manually deleted files in MainAssemblies.
            Also note I have removed BuildFiles from the inputs, the only chnage in buildfiles that would affect solution build
            is if we add or remove a solution, but this would be picked up by new files in AllSourceFilesForBinaries. BuildFiles is gone
            from Fxcop inputs for the same reason -->
		<!-- Copy the fxcop custom dictionary for this solution into VS for the case where we are using built in Fxcop
         verification in the VS2005 (Todo: should we recommend using the external Fxcop provided by SBF only?) -->
		<Exec Condition="Exists('$(VSINSTALLDIR)\Team Tools\Static Analysis Tools\FxCop\CustomDictionary.xml')" Command="attrib -R &quot;$(VSINSTALLDIR)\Team Tools\Static Analysis Tools\FxCop\CustomDictionary.xml&quot;" />
		<Microsoft.Build.Tasks.Copy Condition="Exists('$(VSINSTALLDIR)\Team Tools\Static Analysis Tools\FxCop\FxCopCmd.exe')" SourceFiles="$(BuildPath)\FxCop\%(Solutions.Identity)\CustomDictionary.xml" DestinationFiles="$(VSINSTALLDIR)\Team Tools\Static Analysis Tools\FxCop\CustomDictionary.xml" />
		<CreateProperty Value="0" Condition="('%(Solutions.VSVersion)' == '8.0')">
			<Output TaskParameter="Value" PropertyName="DevEnvExitCode" />
		</CreateProperty>
		<Tools.DevEnv Condition=" ('%(Solutions.VSVersion)' == '7.0') or ('%(Solutions.VSVersion)' == '7.1') " VisualStudio="%(Solutions.VSVersion)" Path="$(SolutionsPath)\%(Solutions.Identity)$(SolutionFolderSuffix)\%(Solutions.Identity).sln" Config="$(Configuration)" Clean="$(Clean)">
			<Output TaskParameter="ExitCode" PropertyName="DevEnvExitCode" />
		</Tools.DevEnv>
		<Error Condition=" '$(DevEnvExitCode)' != '0' " Text="An error occurred building the solution." />
		<CreateProperty Value="Build">
			<Output TaskParameter="Value" PropertyName="TargetToRun" />
		</CreateProperty>
		<CreateProperty Value="ReBuild" Condition=" '$(Clean)' == 'true' ">
			<Output TaskParameter="Value" PropertyName="TargetToRun" />
		</CreateProperty>
		<MSBuild Condition="('%(Solutions.VSVersion)' == '8.0')" Projects="$(SolutionsPath)\%(Solutions.Identity)$(SolutionFolderSuffix)\%(Solutions.Identity).sln" Targets="$(TargetToRun)" Properties="Configuration=$(Configuration)" />
		<!-- Delete any projdata files from the vswebcache so that the vs.net designer can be used without having to perform another build 
             Further note: need to delete projdata from bin folders too otherwise intellisense breaks -->
		<CreateItem Include="$(USERPROFILE)\VSWebCache\**\*.projdata">
			<Output TaskParameter="Include" ItemName="ProjDataFiles" />
		</CreateItem>
		<CreateItem Include="$(SolutionsPath)\%(Solutions.Identity)$(SolutionFolderSuffix)\\**\*.projdata">
			<Output TaskParameter="Include" ItemName="ProjDataFiles" />
		</CreateItem>
		<Microsoft.Build.Tasks.Delete Files="@(ProjDataFiles)" />
		<Touch AlwaysCreate="true" Files="$(BuildPath)\Output\%(Solutions.Identity)\BuildSolutionsMarker.txt" />
		<Touch AlwaysCreate="true" Files="$(BuildPath)\Output\BuildAllSolutionsMarker.txt" />
	</Target>
	<Target Name="CheckComponentInstallation" Condition="'$(CheckInstalledProducts)' == 'true' ">
		<GetInstalledComponents>
			<Output TaskParameter="InstalledComponentsXml" ItemName="InstalledComponentsXml" />
		</GetInstalledComponents>
		<CheckComponentInstalled InstalledComponentsXml="@(InstalledComponentsXml)" Ids="$(ComponentIds)" IdComparisonOperators="$(ComponentIdComparisonOperators)" UnaryOperators="$(ComponentUnaryOperators)">
			<Output TaskParameter="Summary" PropertyName="InstalledComponentsSummary" />
			<Output TaskParameter="Success" PropertyName="InstalledComponentsSuccess" />
		</CheckComponentInstalled>
		<Error Condition=" '$(InstalledComponentsSuccess)' == 'false' " Text="You have missing components. Summary is $(InstalledComponentsSummary)" />
	</Target>
	<!-- ***************************************************************************************************** -->
	<!-- Verifies that project files are generating Xml Documentation and have warnings treated as errors      -->
	<!-- ***************************************************************************************************** -->
	<Target Name="CheckCSProj" DependsOnTargets="BuildAssemblyLists" Inputs="@(Solutions)" Outputs="$(BuildPath)\Output\%(Identity)\CheckCSProj.txt">
		<CreateProperty Value="%(Solutions.VSVersion)">
			<Output TaskParameter="Value" PropertyName="SolutionVSVersion" />
		</CreateProperty>
		<CreateProperty Value="%(Solutions.Identity)">
			<Output TaskParameter="Value" PropertyName="SolutionIdentity" />
		</CreateProperty>
		<Message Text="Solution Version '$(SolutionVSVersion)'" />
		<Message Importance="Low" Text="NDoc targetted projects to be examined '%(NDocAssemblies.Identity)'" Condition="'%(NDocAssemblies.SolutionName)'=='$(SolutionIdentity)'" />
		<Xml.GetValue Condition="'$(SolutionVSVersion)'=='7.1' and '%(NDocAssemblies.SolutionName)'=='$(SolutionIdentity)'" Path="@(NDocAssemblies-&gt;'%(CSProjFile)')" XPath="/VisualStudioProject/CSHARP/Build/Settings/Config/@DocumentationFile[../@Name = 'Debug']" MatchValue="@(NDocAssemblies-&gt;'%(DocumentationFile)')" />
		<Xml.GetValue Condition="'$(SolutionVSVersion)'=='7.1' and '%(NDocAssemblies.SolutionName)'=='$(SolutionIdentity)'" Path="@(NDocAssemblies-&gt;'%(CSProjFile)')" XPath="/VisualStudioProject/CSHARP/Build/Settings/Config/@DocumentationFile[../@Name = 'Release']" MatchValue="@(NDocAssemblies-&gt;'%(DocumentationFile)')" />
		<CreateItem Condition=" '%(NDocAssemblies.ProjectType)' != 'Web' " Include="@(NDocAssemblies)">
			<Output TaskParameter="Include" ItemName="NDocAssembliesWithoutWebProj" />
		</CreateItem>
		<Message Text="'@(NDocAssembliesWithoutWebProj)'" />
		<Xml.GetValue Condition="'$(SolutionVSVersion)'=='8.0' and '%(NDocAssembliesWithoutWebProj.SolutionName)'=='$(SolutionIdentity)'" Path="@(NDocAssembliesWithoutWebProj-&gt;'%(CSProjFile)')" XPath="/*[local-name()='Project']/*[local-name()='PropertyGroup'][contains(@Condition,'Debug|AnyCPU')]/*[local-name()='DocumentationFile']" MatchValue="@(NDocAssembliesWithoutWebProj-&gt;'%(DocumentationFile)')" />
		<Xml.GetValue Condition="'$(SolutionVSVersion)'=='8.0' and '%(NDocAssembliesWithoutWebProj.SolutionName)'=='$(SolutionIdentity)'" Path="@(NDocAssembliesWithoutWebProj-&gt;'%(CSProjFile)')" XPath="/*[local-name()='Project']/*[local-name()='PropertyGroup'][contains(@Condition,'Release|AnyCPU')]/*[local-name()='DocumentationFile']" MatchValue="@(NDocAssembliesWithoutWebProj-&gt;'%(DocumentationFile)')" />
		<Message Importance="Low" Text="Projects to be examined for TreatWarningsAsErrors '%(AllAssembliesFull.Identity)'" Condition="'%(AllAssembliesFull.SolutionName)'=='$(SolutionIdentity)'" />
		<Xml.GetValue Condition="'$(SolutionVSVersion)'=='7.1' and '%(AllAssembliesFull.SolutionName)'=='$(SolutionIdentity)'" Path="@(AllAssembliesFull-&gt;'%(CSProjFile)')" XPath="/VisualStudioProject/CSHARP/Build/Settings/Config/@TreatWarningsAsErrors[../@Name = 'Debug']" MatchValue="true" />
		<Xml.GetValue Condition="'$(SolutionVSVersion)'=='7.1' and '%(AllAssembliesFull.SolutionName)'=='$(SolutionIdentity)'" Path="@(AllAssembliesFull-&gt;'%(CSProjFile)')" XPath="/VisualStudioProject/CSHARP/Build/Settings/Config/@TreatWarningsAsErrors[../@Name = 'Release']" MatchValue="true" />
		<CreateItem Condition=" '%(AllAssembliesFull.ProjectType)' != 'Web' " Include="@(AllAssembliesFull)">
			<Output TaskParameter="Include" ItemName="AllAssembliesFullWithoutWebProj" />
		</CreateItem>
		<Xml.GetValue Condition="'$(SolutionVSVersion)'=='8.0' and '%(AllAssembliesFullWithoutWebProj.SolutionName)'=='$(SolutionIdentity)'" Path="@(AllAssembliesFullWithoutWebProj-&gt;'%(CSProjFile)')" XPath="/*[local-name()='Project']/*[local-name()='PropertyGroup'][contains(@Condition,'Debug|AnyCPU')]/*[local-name()='TreatWarningsAsErrors']" MatchValue="true" />
		<Xml.GetValue Condition="'$(SolutionVSVersion)'=='8.0' and '%(AllAssembliesFullWithoutWebProj.SolutionName)'=='$(SolutionIdentity)'" Path="@(AllAssembliesFullWithoutWebProj-&gt;'%(CSProjFile)')" XPath="/*[local-name()='Project']/*[local-name()='PropertyGroup'][contains(@Condition,'Release|AnyCPU')]/*[local-name()='TreatWarningsAsErrors']" MatchValue="true" />
	</Target>
	<Target Name="CheckDepotForChangesSetup">
		<CreateProperty Value="$(ProductNameBranchPrefix)$(BuildType)$(VersionName)Latest">
			<Output TaskParameter="Value" PropertyName="LatestGoodBuildLabel"></Output>
		</CreateProperty>
		<CreateProperty Value="$(ProductNameBranchPrefix)$(BuildType)$(VersionName)Bad">
			<Output TaskParameter="Value" PropertyName="LatestBadBuildLabel"></Output>
		</CreateProperty>
	</Target>
	<Target Name="CheckDepotForChangesContinuous" DependsOnTargets="LoadVersion;CheckDepotForChangesSetup">
		<!-- Note:  
                you must create two labels as follows in the branch of the depot for which this build will run 
                Create a new 'good' and 'bad' label
                Eg. Branch name (VersionName) = Main, ProductNameBranchPrefix = Lms, BuildType = Continuous

          For Source Depot:-
                sd label LmsContinuousMainLatest               On each you get a dialog:just change the view to map your branch
                Sd label LmsCountinuousMainBad                 eg. //depot/Main/Src/... and hit OK      
                
                Next label all your current files with these two labels:
                
                sd labelsync -l LmsContinuousMainLatest //depot/Main/Src/...
                sd labelsync -l LmsContinuousMainBad //depot/Main/Src/... 


          For TFS :-
                tf label LmsContinuousMainLatest $/MyTeamProject/Main/Src/ /recursive /noprompt
                tf label LmsContinuousMainBad $/MyTeamProject/Main/Src/  /recursive /noprompt
        -->
		<!-- for continuous build we rebuild if there have been changes since the last good build and since the last bad build -->
		<CallTarget Targets="CheckDepotForChangesContinuous_SourceControl" Condition="'$(ForceBuild)'!='true'" />
		<CreateProperty Condition="'$(ForceBuild)'=='true'" Value="true">
			<Output TaskParameter="Value" PropertyName="FilesChanged"></Output>
		</CreateProperty>
	</Target>
	<Target Name="CheckProductInstallation" Condition="'$(CheckInstalledProducts)' == 'true' ">
		<GetInstalledProducts>
			<Output TaskParameter="InstalledProductsXml" ItemName="InstalledProductsXml" />
		</GetInstalledProducts>
		<Message Text="Installed products are @(InstalledProductsXml)" Importance="Low" />
		<CheckProductInstalled InstalledProductsXml="@(InstalledProductsXml)" Names="$(Names)" NameComparisonOperators="$(NameComparisonOperators)" VersionComparisonOperators="$(VersionComparisonOperators)" Versions="$(Versions)" UnaryOperators="$(UnaryOperators)">
			<Output TaskParameter="Summary" PropertyName="InstalledProductsSummary" />
			<Output TaskParameter="Success" PropertyName="InstalledProductsSuccess" />
		</CheckProductInstalled>
		<Error Condition=" '$(InstalledProductsSuccess)' == 'false' " Text="You have missing products. Summary is $(InstalledProductsSummary)" />
	</Target>
	<!-- This task is required because the SetupDev Target's dependencies should not run if the outputs below are up to date.
         However dependencies are run before inputs/outputs are checked and hence we need a separate task to eval the dependencies first.
         ALSO note the use of 'ValueSetByTask' below instead of Value which would always set the property DoSetupDev even if
         CheckSetupDevs outputs were up to date -->
	<Target Name="CheckSetupDev" Inputs="@(BuildFiles)" Outputs="$(BuildPath)\Output\SetupDevMarker.txt" DependsOnTargets="ForceSteps">
		<CreateProperty Value="true">
			<Output TaskParameter="ValueSetByTask" PropertyName="DoSetupDev"></Output>
		</CreateProperty>
	</Target>
	<Target Name="CleanSolution" Condition=" '$(Clean)' == 'true' or '$(CleanSolution)' == 'true' " DependsOnTargets="BuildAssemblyLists;$(CleanSolutionDependsOn)">
		<!-- Delete and recreate the output folder for each solution -->
		<RemoveDir Condition=" Exists('$(SolutionsPath)\%(Solutions.Identity)Assemblies') " Directories="$(SolutionsPath)\%(Solutions.Identity)Assemblies" />
		<MakeDir Directories="$(SolutionsPath)\%(Solutions.Identity)Assemblies" />
		<Delete Files="$(BuildPath)\Output\%(Solutions.Identity)\BuildSolutionsMarker.txt" />
		<Delete Files="$(BuildPath)\Output\BuildAllSolutionsMarker.txt" />
		<!-- destroy all old binaries -->
		<CreateItem Include="$(SolutionsPath)\%(Solutions.Identity)$(SolutionFolderSuffix)\**\obj\**">
			<Output TaskParameter="Include" ItemName="SolutionOutputFiles" />
		</CreateItem>
		<CreateItem Include="$(SolutionsPath)\%(Solutions.Identity)$(SolutionFolderSuffix)\**\bin\**">
			<Output TaskParameter="Include" ItemName="SolutionOutputFiles" />
		</CreateItem>
		<CreateItem Include="$(SolutionsPath)\%(Solutions.Identity)$(SolutionFolderSuffix)\*.ncb">
			<Output TaskParameter="Include" ItemName="SolutionOutputFiles" />
		</CreateItem>
		<Delete Condition="'@(SolutionOutputFiles)'!=''" Files="@(SolutionOutputFiles)" />
	</Target>
	<Target Name="CodeCoverage" DependsOnTargets="BuildAssemblyLists;ForceSteps;LoadVersion;$(TestsDependsOn)" Inputs="@(BuildFiles);@(TestScriptDependencies);@(NUnitAssemblies);$(BuildPath)\Output\DatabaseMarker.txt" Outputs="$(BuildPath)\Output\Test\CodeCoverageMarker.txt" Condition="'$(RunCodeCoverage)'=='true' and '$(FilesChanged)'=='true'">
		<Time.Get>
			<Output TaskParameter="Time" PropertyName="BuildStartTime" />
		</Time.Get>
		<CreateProperty Condition="'$(LogFile)'!=''" Value="@(LogFileWithMetaData-&gt;'&lt;br&gt;&lt;A href=file:\\$(COMPUTERNAME)\BuildLogs\$(BuildType)\%(FileName)%(Extension)&gt;MSBuild Log File&lt;/A&gt;&lt;br&gt;')">
			<Output TaskParameter="Value" PropertyName="EmailLinkToLogFile" />
		</CreateProperty>
		<MSBuild Projects="$(BuildPath)\Test.proj" Properties="&#xD;&#xA;                BuildPath=$(BuildPath);&#xD;&#xA;                FrameworkPath=$(FrameworkPath);&#xD;&#xA;                VersionNumber=$(VersionNumber);&#xD;&#xA;                BuildType=CodeCoverage;&#xD;&#xA;                StopOnTestError=false" Targets="CodeCoverage" />
		<Email ContinueOnError="$(ContinueBuildOnEmailError)" Condition=" '$(Email)' == 'true' " Subject="$(ProductName) $(BuildType) Code Coverage Report v$(VersionNumber)" Body="&lt;h4&gt;$(BuildType) Code Coverage Report successful.&lt;/h4&gt; &lt;br&gt;&lt;br&gt; Build started at $(BuildStartTime) &lt;br&gt; $(EmailLinkToLogFile) &lt;br&gt;&lt;br&gt;Build Framework v$(SDGBuildFrameworkVersion)." SmtpServer="$(SmtpServer)" MailFrom="$(MailFrom)" Attachments="$(BuildPath)\Output\CodeCoverage\BuildReportCodeCoverage.htm" MailTo="$(CodeCoverageMailTo)"></Email>
		<Touch AlwaysCreate="true" Files="$(BuildPath)\Output\Test\CodeCoverageMarker.txt" />
	</Target>
	<Target Name="CopyAdditionalFiles" Inputs="@(AdditionalAssembliesFiles)" Outputs="@(AdditionalAssembliesFiles-&gt;'$(SolutionsPath)\%(SolutionName)Assemblies\%(FileName)%(Extension)')">
		<Microsoft.Build.Tasks.Copy Condition=" '@(AdditionalAssembliesFiles)' != '' " SourceFiles="@(AdditionalAssembliesFiles)" DestinationFolder="$(SolutionsPath)\%(AdditionalAssembliesFiles.SolutionName)Assemblies" />
	</Target>
	<Target Name="CreateAppPools" Condition=" '@(AppPoolsToCreate)' != '' ">
		<Web.AppPool.Create AppPoolName="%(AppPoolsToCreate.Identity)" IdentityType="SpecifiedUserAccount" Identity="%(AppPoolsToCreate.UserName)" Password="%(AppPoolsToCreate.UserPassword)" />
	</Target>
	<Target Name="CreateDatabases" DependsOnTargets="ForceSteps" Inputs="@(DatabaseDependencies);@(Databases)" Outputs="$(BuildPath)\Output\DatabaseMarker.txt" Condition="'@(Databases)'!='' AND '$(KeepData)'!='true'">
		<MSBuild Projects="%(Databases.Identity)" Condition="'$(KeepData)'!='true'" Properties="BuildPath=$(BuildPath);&#xD;&#xA;                        FrameworkPath=$(FrameworkPath)" />
		<CreateProperty Value="true">
			<Output TaskParameter="ValueSetByTask" PropertyName="DatabaseBuilt"></Output>
		</CreateProperty>
		<Touch AlwaysCreate="true" Files="$(BuildPath)\Output\DatabaseMarker.txt" />
	</Target>
	<Target Name="CreateDefaultWebSiteEntry" Condition="'@(WebSitesToCreateFull)'==''">
		<CreateItem Include="Default Web Site" AdditionalMetadata="ItemList2_Identity=1">
			<Output TaskParameter="Include" ItemName="WebSitesToCreateFull" />
		</CreateItem>
	</Target>
	<Target Name="CreateDrop" DependsOnTargets="$(CreateDropDependsOn)" />
	<Target Name="CoreCreateDrop" DependsOnTargets="LoadVersion;BuildAssemblyLists;ForceSteps" Inputs="$(BuildPath)\Output\BuildAllSolutionsMarker.txt;$(BuildPath)\Output\BuildInstallersMarker.txt" Outputs="$(BuildPath)\Output\DropMarker.txt">
		<Message Text="Creating drop location \\$(ReleaseServer)\Drops\$(ProductDropName)\$(VersionName)\$(VersionNumber)" />
		<CreateProperty Value="\\$(ReleaseServer)\Drops\$(ProductDropName)\$(VersionName)\$(VersionNumber)">
			<Output TaskParameter="Value" PropertyName="ProductDropRootPath" />
		</CreateProperty>
		<Error Condition="Exists($(ProductDropRootPath))" Text="A drop has already been created with this version number" />
		<MakeDir Directories="$(ProductDropRootPath)" />
		<!-- this section copies the build framework itself to the test folder -->
		<File.GetFiles Path="$(BuildPath)" Masks="*.properties;*.proj" Recursive="False">
			<Output TaskParameter="OutputFiles" ItemName="Properties_Files" />
		</File.GetFiles>
		<File.GetFiles Path="$(BuildPath)\bin" Masks="*.*" Recursive="False">
			<Output TaskParameter="OutputFiles" ItemName="MsBuild_Files" />
		</File.GetFiles>
		<Microsoft.Build.Tasks.Copy SourceFiles="@(MsBuild_Files)" DestinationFolder="$(ProductDropRootPath)\Test\bin" />
		<Microsoft.Build.Tasks.Copy SourceFiles="@(Properties_Files)" DestinationFolder="$(ProductDropRootPath)\Test" />
		<!-- this section copies the deploy framework to the Install Folder -->
		<File.GetFiles Path="$(BuildPath)\Deployment" Masks="*.*" Recursive="False">
			<Output TaskParameter="OutputFiles" ItemName="Rig_Template_Files" />
		</File.GetFiles>
		<CreateItem Include="$(BuildPath)\Deployment\Framework\**\*.*">
			<Output TaskParameter="Include" ItemName="Deploy_Framework_Files" />
		</CreateItem>
		<Microsoft.Build.Tasks.Copy SourceFiles="@(Rig_Template_Files)" DestinationFolder="$(ProductDropRootPath)\Install\RigTemplates" />
		<Microsoft.Build.Tasks.Copy SourceFiles="@(Deploy_Framework_Files)" DestinationFiles="@(Deploy_Framework_Files-&gt;'$(ProductDropRootPath)\Install\Framework\%(RecursiveDir)%(Filename)%(Extension)')" />
		<!-- copy the folders specified in build.properties -->
		<Microsoft.Sdc.Tasks.Folder.Copy Condition="'%(Drop_FolderCopy.DestinationPropertyName)'==''" Source="%(Drop_FolderCopy.Identity)" Destination="$(ProductDropRootPath)%(Drop_FolderCopy.Destination)" />
		<Microsoft.Sdc.Tasks.Folder.Copy Condition="'%(Drop_FolderCopy.DestinationPropertyName)'!=''" Source="%(Drop_FolderCopy.Identity)" Destination="$(ProductDropRootPath)%(Drop_FolderCopy.Destination)$(%(Drop_FolderCopy.DestinationPropertyName))" />
		<!-- copy the Files specified in build.properties -->
		<Microsoft.Build.Tasks.Copy Condition="'%(Drop_FileCopy.File)'==''" SourceFiles="%(Drop_FileCopy.Identity)" DestinationFolder="$(ProductDropRootPath)%(Drop_FileCopy.Destination)" />
		<Microsoft.Build.Tasks.Copy Condition="'%(Drop_FileCopy.File)'!=''" SourceFiles="%(Drop_FileCopy.Identity)" DestinationFiles="$(ProductDropRootPath)%(Drop_FileCopy.Destination)%(Drop_FileCopy.File)" />
		<!-- Delete unwanted folders and files -->
		<RemoveDir Condition="'@(Drop_FolderDelete)'!='' AND '%(Drop_FolderDelete.MatchFiles)'==''" Directories="$(ProductDropRootPath)%(Drop_FolderDelete.Identity)" />
		<CreateItem Condition="'@(Drop_FolderDelete)'!=''" Include="$(ProductDropRootPath)%(Drop_FolderDelete.MatchFiles)">
			<Output TaskParameter="Include" ItemName="DropFilesToDelete" />
		</CreateItem>
		<Delete Files="@(DropFilesToDelete)" />
		<!-- make any post drop file mods required -->
		<File.RegEx Condition="'@(Drop_ModifyFile)'!='' AND '%(Drop_ModifyFile.MatchFiles)'=='' AND '%(Drop_ModifyFile.NewValuePropertyName)'==''" Path="$(ProductDropRootPath)%(Drop_ModifyFile.Identity)" RegularExpression="%(Drop_ModifyFile.RegularExpression)" NewValue="%(Drop_ModifyFile.NewValue)" Force="true" />
		<File.RegEx Condition=" '@(Drop_ModifyFile)'!='' AND '%(Drop_ModifyFile.MatchFiles)'=='' AND '%(Drop_ModifyFile.NewValuePropertyName)'!=''" Path="$(ProductDropRootPath)%(Drop_ModifyFile.Identity)" RegularExpression="%(Drop_ModifyFile.RegularExpression)" NewValue="%(Drop_ModifyFile.NewValue)$(%(Drop_ModifyFile.NewValuePropertyName))%(Drop_ModifyFile.NewValuePostProperty)" Force="true" />
		<CreateItem Include="$(ProductDropRootPath)%(Drop_ModifyFile.MatchFiles)" Condition="'@(Drop_ModifyFile)'!='' AND '%(Drop_ModifyFile.MatchFiles)'!=''" AdditionalMetadata="RegularExpression=%(Drop_ModifyFile.RegularExpression);NewValue=%(Drop_ModifyFile.NewValue);NewValuePropertyName=%(Drop_ModifyFile.NewValuePropertyName);NewValuePostProperty=%(Drop_ModifyFile.NewValuePostProperty)">
			<Output TaskParameter="Include" ItemName="MatchingFilesToModify" />
		</CreateItem>
		<File.RegEx Condition="'@(MatchingFilesToModify)'!='' AND '%(MatchingFilesToModify.NewValuePropertyName)'==''" Path="%(MatchingFilesToModify.Identity)" RegularExpression="%(MatchingFilesToModify.RegularExpression)" NewValue="%(MatchingFilesToModify.NewValue)" Force="true" />
		<File.RegEx Condition=" '@(MatchingFilesToModify)'!='' AND '%(MatchingFilesToModify.NewValuePropertyName)'!=''" Path="%(MatchingFilesToModify.Identity)" RegularExpression="%(MatchingFilesToModify.RegularExpression)" NewValue="%(MatchingFilesToModify.NewValue)$(%(MatchingFilesToModify.NewValuePropertyName))%(MatchingFilesToModify.NewValuePostProperty)" Force="true" />
		<!-- zip up the drop folder -->
		<MakeDir Directories="$(ProductDropRootPath)Temp" />
		<Zip.AddFile Condition="'$(CreateDropZip)'=='true'" PathToZipFile="$(ProductDropRootPath)Temp\$(VersionNumber).zip" PathToFile="$(ProductDropRootPath)" />
		<Microsoft.Build.Tasks.Copy Condition="'$(CreateDropZip)'=='true'" SourceFiles="$(ProductDropRootPath)Temp\$(VersionNumber).zip" DestinationFiles="$(ProductDropRootPath)\$(VersionNumber).zip" />
		<RemoveDir Directories="$(ProductDropRootPath)Temp" />
		<CreateProperty Value="true">
			<Output TaskParameter="Value" PropertyName="FileDropCompleted" />
		</CreateProperty>
		<Touch AlwaysCreate="true" Files="$(BuildPath)\Output\DropMarker.txt" />
	</Target>
	<Target Name="CreateEventSources" Condition=" '@(EventSourcesToCreate)' != '' " Inputs="$(FrameworkPath)\Marker.txt" Outputs="$(BuildPath)\%(EventSourcesToCreate.Identity)Dummy">
		<EventSource.Exists Source="%(EventSourcesToCreate.Identity)" LogName="%(EventSourcesToCreate.LogName)">
			<Output TaskParameter="DoesExist" PropertyName="EventSourceExists" />
		</EventSource.Exists>
		<EventSource.Create Condition=" '$(EventSourceExists)' == 'false' " Source="%(EventSourcesToCreate.Identity)" LogName="%(EventSourcesToCreate.LogName)" />
	</Target>
	<Target Name="CreateGroups" Condition=" '@(Groups)' != '' ">
		<Message Text="Creating groups: @(Groups)" />
		<ActiveDirectory.Group.Create GroupName="%(Groups.Identity)" DomainName="%(Groups.DomainName)" EnsureGroup="%(Groups.EnsureGroup)" />
	</Target>
	<Target Name="CreatePerformanceCounters" Condition=" '@(PerformanceCounterCategoriesToCreate)' != '' " Inputs="$(FrameworkPath)\Marker.txt" Outputs="$(BuildPath)\%(PerformanceCounterCategoriesToCreate.Identity)Dummy">
		<CreateProperty Value="%(PerformanceCounterCategoriesToCreate.Identity)">
			<Output TaskParameter="Value" PropertyName="PerformanceCounterCategoryIdentity" />
		</CreateProperty>
		<CreateItem Include="@(PerformanceCountersToCreate)" Condition=" '%(PerformanceCountersToCreate.CategoryName)' == '$(PerformanceCounterCategoryIdentity)' " AdditionalMetadata="CounterName=%(PerformanceCountersToCreate.Identity);&#xD;&#xA;                          CounterHelp=%(PerformanceCountersToCreate.Help);&#xD;&#xA;                          CounterType=%(PerformanceCountersToCreate.Type)">
			<Output TaskParameter="Include" ItemName="CategoryPerformanceCounters" />
		</CreateItem>
		<Error Condition=" '@(CategoryPerformanceCounters)' == '' " Text="There are no performance counters to create in the &quot;$(PerformanceCounterCategoryIdentity)&quot; category." />
		<PerformanceCounters.Add CategoryName="$(PerformanceCounterCategoryIdentity)" CategoryHelp="%(PerformanceCounterCategoriesToCreate.Help)" MultiInstance="%(PerformanceCounterCategoriesToCreate.MultiInstance)" CounterList="@(CategoryPerformanceCounters)" />
		<Message Text="Creating performance counter &quot;%(CategoryPerformanceCounters.Identity)&quot;." />
	</Target>
	<Target Name="CreateOutputFolders">
		<MakeDir Directories="$(BuildPath)\Output\%(Solutions.Identity)" />
	</Target>
	<Target Name="CreateFolders" Condition=" '@(FoldersToCreate)' != '' ">
		<MakeDir Directories="%(FoldersToCreate.Identity)" />
	</Target>
	<Target Name="CreateFtpSites" Condition=" '@(FtpSitesToCreate)' != '' ">
		<Web.FtpSite.Create Description="%(FtpSitesToCreate.Identity)" Path="%(FtpSitesToCreate.Path)" Port="%(FtpSitesToCreate.Port)" AccessFlags="%(FtpSitesToCreate.AccessFlags)" AllowAnonymous="%(FtpSitesToCreate.AllowAnonymous)" AnonymousUserName="%(FtpSitesToCreate.AnonymousUserName)" AnonymousUserPass="%(FtpSitesToCreate.AnonymousUserPass)" />
	</Target>
	<Target Name="CreateFtpVirtualDirectories" Condition=" '@(FtpVirtualDirectoriesToCreate)' != '' ">
		<Web.FtpSite.CreateVirtualDirectory VirtualDirectoryName="%(FtpVirtualDirectoriesToCreate.Identity)" Path="%(FtpVirtualDirectoriesToCreate.Path)" FtpSiteName="%(FtpVirtualDirectoriesToCreate.FtpSiteName)" AccessFlags="%(FtpVirtualDirectoriesToCreate.AccessFlags)" />
	</Target>
	<Target Name="CreateShares" Condition=" '@(SharesToCreate)' != '' " Inputs="$(FrameworkPath)\Marker.txt" Outputs="$(BuildPath)\%(SharesToCreate.Identity)Dummy">
		<Share.Exists ShareName="%(SharesToCreate.Identity)">
			<Output TaskParameter="DoesExist" PropertyName="ShareExists" />
		</Share.Exists>
		<Share.Create Condition=" '$(ShareExists)' == 'false' " ShareName="%(SharesToCreate.Identity)" Machine="%(SharesToCreate.Machine)" Path="%(SharesToCreate.Path)" Description="%(SharesToCreate.Description)" AllowedUsers="%(SharesToCreate.Users)" />
	</Target>
	<Target Name="CreateUsers" Condition=" '@(Users)' != '' ">
		<Message Text="Creating Users: @(Users)" />
		<ActiveDirectory.User.Create Condition="'%(Users.PasswordExpires)'==''" UserName="%(Users.Identity)" Password="%(Users.Password)" EnsureUser="true" />
		<ActiveDirectory.User.Create Condition="'%(Users.PasswordExpires)'!=''" UserName="%(Users.Identity)" Password="%(Users.Password)" EnsureUser="true" PasswordExpires="%(Users.PasswordExpires)" />
	</Target>
	<Target Name="CreateWebServiceExtensions" Condition=" '@(WebServiceExtensionsToCreate)' != '' " Inputs="$(FrameworkPath)\Marker.txt" Outputs="$(BuildPath)\%(WebServiceExtensionsToCreate.Identity)Dummy">
		<ShortenPath inputPath="%(WebServiceExtensionsToCreate.Identity)">
			<Output TaskParameter="outputPath" PropertyName="NormalisedPath" />
		</ShortenPath>
		<Web.ServiceExtension.AddFile Path="$(NormalisedPath)" Description="%(WebServiceExtensionsToCreate.Description)" GroupID="%(WebServiceExtensionsToCreate.GroupID)" Deleteable="%(WebServiceExtensionsToCreate.Deleteable)" Permission="%(WebServiceExtensionsToCreate.Permission)" />
	</Target>
	<Target Name="CreateWebSites" Condition=" '@(WebSitesToCreate)' != '' ">
		<Web.WebSite.Create Port="%(WebSitesToCreate.Port)" Description="%(WebSitesToCreate.Identity)" Path="%(WebSitesToCreate.Path)" AuthFlags="%(WebSitesToCreate.AuthFlags)" AppPoolId="%(WebSitesToCreate.AppPoolId)" HttpExpires="%(WebSitesToCreate.HttpExpires)" HostName="%(WebSitesToCreate.HostName)" LogFileDir="%(WebSitesToCreate.LogFileDir)" Identifier="%(WebSitesToCreate.Identifier)">
			<Output TaskParameter="Identifier" ItemName="WebSiteIdentifiers" />
		</Web.WebSite.Create>
		<MergeByOrder ItemList1="@(WebSitesToCreate)" ItemList2="@(WebSiteIdentifiers)">
			<Output TaskParameter="MergedList" ItemName="WebSitesToCreateFull"></Output>
		</MergeByOrder>
		<Message Text="@(WebSitesToCreateFull)" />
		<Exec Condition="'%(WebSitesToCreateFull.AspNetVersion)' != ''" Command="$(WINDIR)\\Microsoft.NET\Framework\v%(WebSitesToCreateFull.AspNetVersion)\aspnet_regiis -s W3SVC/%(WebSitesToCreateFull.ItemList2_Identity)/root" />
		<AddCertificate Condition="'%(WebSitesToCreate.SSL_Certificate)'!=''" FileName="%(WebSitesToCreate.SSL_Certificate)" MachineStore="true">
			<Output TaskParameter="Thumbprint" PropertyName="NewCertHash" />
		</AddCertificate>
		<!-- todo: currently this only works if all sites use the same certificate (which would usuasly be true) -->
		<UpdateServerCertificate Condition="'%(WebSitesToCreate.SSL_Certificate)'!=''" Description="%(WebSitesToCreate.Identity)" Thumbprint="$(NewCertHash)" CertificateStore="MY" SslAccessFlags="%(WebSitesToCreate.SSL_AccessFlags)"></UpdateServerCertificate>
		<Web.WebSite.AddBinding Condition="'%(WebSitesToCreate.SSL_Certificate)'!=''" Description="%(WebSitesToCreate.Identity)" Port="%(WebSitesToCreate.SSL_Port)" Secure="true" />
		<WebSite.UpdateLogSettings Condition="'%(WebSitesToCreate.LogExtFileFlags)%(WebSitesToCreate.LogFilePeriod)%(WebSitesToCreate.LogFileLocaltimeRollover)%(WebSitesToCreate.LogFileTruncateSize)'!=''" Description="%(WebSitesToCreate.Identity)" LogFileLocaltimeRollover="%(WebSitesToCreate.LogFileLocaltimeRollover)" LogExtFileFlags="%(WebSitesToCreate.LogExtFileFlags)" LogFileTruncateSize="%(WebSitesToCreate.LogFileTruncateSize)" LogFilePeriod="%(WebSitesToCreate.LogFilePeriod)" />
	</Target>
	<Target Name="CreateWebVirtualDirectories" DependsOnTargets="GetIISRootScriptMapVersion;MapWebSiteIdentifiers" Condition=" '@(WebVirtualDirectoriesToCreate)' != '' ">
		<Message Text="CreatingVDirs @(WebVirtualDirectoriesToCreate-&gt;'%(Identity) at %(Path)','&#xA;')" />
		<Web.WebSite.CreateVirtualDirectory Condition="'%(WebVirtualDirectoriesToCreate.AppCreate)'==''" VirtualDirectoryName="%(WebVirtualDirectoriesToCreate.Identity)" Path="%(WebVirtualDirectoriesToCreate.Path)" WebSiteName="%(WebVirtualDirectoriesToCreate.WebSiteName)" AppPoolId="%(WebVirtualDirectoriesToCreate.AppPoolId)" UncUserName="%(WebVirtualDirectoriesToCreate.UncUserName)" UncPassword="%(WebVirtualDirectoriesToCreate.UncPassword)" AuthFlags="%(WebVirtualDirectoriesToCreate.AuthFlags)" AccessFlags="%(WebVirtualDirectoriesToCreate.AccessFlags)" WebAppName="%(WebVirtualDirectoriesToCreate.WebAppName)" />
		<Web.WebSite.CreateVirtualDirectory Condition="'%(WebVirtualDirectoriesToCreate.AppCreate)'!=''" VirtualDirectoryName="%(WebVirtualDirectoriesToCreate.Identity)" Path="%(WebVirtualDirectoriesToCreate.Path)" WebSiteName="%(WebVirtualDirectoriesToCreate.WebSiteName)" AppPoolId="%(WebVirtualDirectoriesToCreate.AppPoolId)" UncUserName="%(WebVirtualDirectoriesToCreate.UncUserName)" UncPassword="%(WebVirtualDirectoriesToCreate.UncPassword)" AuthFlags="%(WebVirtualDirectoriesToCreate.AuthFlags)" AccessFlags="%(WebVirtualDirectoriesToCreate.AccessFlags)" AppCreate="%(WebVirtualDirectoriesToCreate.AppCreate)" WebAppName="%(WebVirtualDirectoriesToCreate.WebAppName)" />
		<Exec Condition="'%(WebVirtualDirectoriesToCreateFull.AspNetVersion)'!='' and '$(AspNetVersion)'!='%(WebVirtualDirectoriesToCreateFull.AspNetVersion)'" Command="$(MSBuildBinPath)\..\v%(WebVirtualDirectoriesToCreateFull.AspNetVersion)\aspnet_regiis.exe -s W3SVC/%(WebVirtualDirectoriesToCreateFull.WebSiteIdentifier)/root/%(WebVirtualDirectoriesToCreateFull.Identity)" />
	</Target>
	<Target Name="DeleteAppPools" Condition=" '@(WebSitesToDelete)' != '' ">
		<Web.AppPool.Delete Condition=" '%(WebSitesToDelete.AppPoolName)' != '' " ContinueOnError="true" AppPoolName="%(WebSitesToDelete.AppPoolName)" />
	</Target>
	<Target Name="DeleteAssemblyDownloadCache">
		<RemoveDir Directories="$(APPDATA)\Assembly" />
		<MakeDir Directories="$(APPDATA)\Assembly" />
		<RemoveDir Directories="$(APPDATA)\..\Local Settings\Application Data\assembly" />
		<MakeDir Directories="$(APPDATA)\..\Local Settings\Application Data\assembly" />
	</Target>
	<Target Name="DeleteFolders" Condition=" '$(Clean)' == 'true' ">
		<RemoveDir Directories="%(FoldersToDelete.Identity)" Condition=" '@(FoldersToDelete)' != '' " />
	</Target>
	<Target Name="DeleteFtpSites" Condition=" '@(FtpSitesToDelete)' != '' ">
		<Web.FtpSite.Stop ContinueOnError="true" Description="%(FtpSitesToDelete.Identity)" />
		<Web.FtpSite.Delete ContinueOnError="true" Description="%(FtpSitesToDelete.Identity)" />
	</Target>
	<Target Name="DeleteFtpVirtualDirectories" Condition=" '@(FtpVirtualDirectoriesToDelete)' != '' ">
		<Web.FtpSite.DeleteVirtualDirectory ContinueOnError="true" VirtualDirectoryName="%(FtpVirtualDirectoriesToDelete.Identity)" />
	</Target>
	<Target Name="DeleteOutputFiles">
		<RemoveDir Directories="$(BuildPath)\Output" Condition=" '$(Clean)' == 'true' " />
		<!-- remove those files that go into reports so that old info is not shown in a build that skips creating these -->
		<CreateItem Include="$(BuildPath)\Output\Test\**\*.htm">
			<Output TaskParameter="Include" ItemName="PreviousResultsFiles" />
		</CreateItem>
		<CreateItem Include="$(BuildPath)\Output\%(Solutions.Identity).sln.$(Configuration).txt">
			<Output TaskParameter="Include" ItemName="PreviousResultsFiles" />
		</CreateItem>
		<CreateItem Include="Exists('$(BuildPath)\Output\%(Solutions.Identity)\*Errors.xml">
			<Output TaskParameter="Include" ItemName="PreviousResultsFiles" />
		</CreateItem>
		<Delete Files="@(PreviousResultsFiles)" />
	</Target>
	<Target Name="DeletePerformanceCounters" Condition=" '@(PerformanceCounterCategoriesToDelete)' != '' ">
		<PerformanceCounters.Remove CategoryName="%(PerformanceCounterCategoriesToDelete.Identity)" />
	</Target>
	<Target Name="DeleteShares" Condition=" '@(SharesToDelete)' != '' AND '$(Clean)' == 'true'" Inputs="$(FrameworkPath)\Marker.txt" Outputs="$(BuildPath)\%(SharesToDelete.Identity)Dummy">
		<!-- Note Dummy outputs above cause this target to *always* iterate over each SharesToDelete item -->
		<Share.Exists ShareName="%(SharesToDelete.Identity)">
			<Output TaskParameter="DoesExist" PropertyName="ShareExists" />
		</Share.Exists>
		<Message Condition=" '$(ShareExists)' == 'true' " Text="Deleting Share %(SharesToDelete.Identity)" />
		<Share.Delete Condition=" '$(ShareExists)' == 'true' " ShareName="%(SharesToDelete.Identity)" />
	</Target>
	<Target Name="DeleteTempSolutionFiles">
		<!-- Don't delete any user files any more
        However it is important not to allow the checkin of the following files
          $(SolutionsPath)\**\.webinfo
          $(SolutionsPath)\**\*.suo
          $(SolutionsPath)\**\*.user
          $(SolutionsPath)\**\*.xml
    <CreateItem Include="$(SolutionsPath)\**\.webinfo;$(SolutionsPath)\**\*.suo">
      <Output TaskParameter="Include" ItemName="TempSolutionFilesToRemove"/>
    </CreateItem>
    <Microsoft.Build.Tasks.Delete Files="@(TempSolutionFilesToRemove)" />  -->
	</Target>
	<Target Name="DeleteVSWebCache">
		<RemoveDir ContinueOnError="true" Directories="$(USERPROFILE)\VSWebCache" />
	</Target>
	<Target Name="DeleteWebServiceExtensions" Condition=" '@(WebServiceExtensionsToDelete)' != '' " Inputs="$(FrameworkPath)\Marker.txt" Outputs="$(BuildPath)\%(WebServiceExtensionsToDelete.Identity)Dummy">
		<ShortenPath inputPath="%(WebServiceExtensionsToDelete.Identity)">
			<Output TaskParameter="outputPath" PropertyName="NormalisedPath" />
		</ShortenPath>
		<Web.ServiceExtension.DeleteFile Path="$(NormalisedPath)" ContinueOnError="true" />
	</Target>
	<Target Name="DeleteWebSites" Condition=" '@(WebSitesToDelete)' != '' ">
		<Web.WebSite.Stop ContinueOnError="true" Description="%(WebSitesToDelete.Identity)" />
		<Web.WebSite.Delete ContinueOnError="true" Description="%(WebSitesToDelete.Identity)" />
	</Target>
	<Target Name="DeleteWebVirtualDirectories" Condition=" '@(WebVirtualDirectoriesToDelete)' != '' ">
		<Web.WebSite.DeleteVirtualDirectory ContinueOnError="true" VirtualDirectoryName="%(WebVirtualDirectoriesToDelete.Identity)" WebSiteName="%(WebVirtualDirectoriesToDelete.WebSiteName)" />
	</Target>
	<Target Name="Deploy" Inputs="$(BuildPath)\Output\BuildInstallersMarker.txt" Outputs="$(BuildPath)\Output\DeployMarker.txt" DependsOnTargets="ForceSteps">
		<MSBuild Projects="$(BuildPath)\Deploy.proj" Properties="BuildType=$(BuildType);" Targets="DeploySetupDeployOnSingleServer" />
		<Touch AlwaysCreate="true" Files="$(BuildPath)\Output\DeployMarker.txt" />
		<!-- once we have deployed then the DB is built (for the purposes of Test Target Inputs/Outputs) -->
		<Touch AlwaysCreate="true" Files="$(BuildPath)\Output\DatabaseMarker.txt" />
	</Target>
	<Target Name="EmailLinkFiles" DependsOnTargets="EmailLinkDrop" Condition="'$(AbandonBuild)'!='true' AND '$(LogFile)'!=''">
		<!-- Todo. This use of 'exec Command=type' is Naff, update the report summary and test summary tasks to do this properly -->
		<!-- copy all build step output into a single file -->
		<Exec Condition="Exists('$(BuildPath)\Output\%(Solutions.Identity)\FxCopErrors.xml')" Command="type $(BuildPath)\Output\%(Solutions.Identity)\FxCopErrors.xml &gt;&gt; $(EmailBuildResults)" />
		<Exec Condition="Exists('$(BuildPath)\Output\%(Solutions.Identity).sln.$(Configuration).txt')" Command="type $(BuildPath)\Output\%(Solutions.Identity).sln.$(Configuration).txt &gt;&gt; $(EmailBuildResults)" />
		<Exec Condition="Exists('$(BuildPath)\Output\%(Solutions.Identity)\StyleCopErrors.xml')" Command="type $(BuildPath)\Output\%(Solutions.Identity)\StyleCopErrors.xml &gt;&gt; $(EmailBuildResults)" />
		<!-- copy all test results into a single file -->
		<CreateItem Include="$(BuildPath)\Output\Test\Formatted\*.htm">
			<Output TaskParameter="Include" ItemName="TestOutputFiles" />
		</CreateItem>
		<Exec Condition="'@(TestOutputFiles)'!=''" Command="type %(TestOutputFiles.Identity) &gt;&gt; $(EmailTestResults)" />
		<Exec Condition="Exists('$(BuildPath)\Output\Test\Summary.html')" Command="type $(BuildPath)\Output\Test\Summary.html &gt;&gt; $(EmailTestSummary)" />
		<!-- create links to go in final email -->
		<CreateProperty Condition="Exists('$(EmailTestResults)')" Value="&lt;br&gt;&lt;A href=file:\\$(COMPUTERNAME)\BuildLogs\$(BuildType)\$(FilePrefix)TestResults.htm&gt;Test Results&lt;/A&gt;&lt;br&gt;">
			<Output TaskParameter="Value" PropertyName="EmailLinkToTestResults" />
		</CreateProperty>
		<CreateProperty Condition="Exists('$(EmailTestSummary)')" Value="&lt;br&gt;&lt;A href=file:\\$(COMPUTERNAME)\BuildLogs\$(BuildType)\$(FilePrefix)TestSummary.htm&gt;Test Summary&lt;/A&gt;&lt;br&gt;">
			<Output TaskParameter="Value" PropertyName="EmailLinkToTestSummary" />
		</CreateProperty>
		<CreateProperty Condition="Exists('$(EmailBuildResults)')" Value="&lt;br&gt;&lt;A href=file:\\$(COMPUTERNAME)\BuildLogs\$(BuildType)\$(FilePrefix)SolutionBuildResults.txt&gt;Solution Build Results&lt;/A&gt;&lt;br&gt;">
			<Output TaskParameter="Value" PropertyName="EmailLinkToBuildResults" />
		</CreateProperty>
	</Target>
	<Target Name="EmailLinkDrop">
		<CreateProperty Condition="'$(FileDropCompleted)'=='true'" Value="&lt;br&gt;&lt;A href=file:$(ProductDropRootPath)&gt;Drop Folder for Build v$(VersionNumber)&lt;/A&gt;&lt;br&gt;">
			<Output TaskParameter="Value" PropertyName="EmailLinkToDrop" />
		</CreateProperty>
	</Target>
	<Target Name="EmailSetupFileNames">
		<!-- determine to whom emails will be delivered. TestingEmail Property limits emails to only go to 'MailTo' -->
		<CreateItem Include="$(MailTo)" Condition="'$(BuildType)'!='Daily' OR '$(TestingEmail)'=='true'">
			<Output TaskParameter="Include" ItemName="MailRecipients" />
		</CreateItem>
		<CreateItem Include="$(MailToDaily)" Condition="'$(BuildType)'=='Daily' AND '$(TestingEmail)'!='true'">
			<Output TaskParameter="Include" ItemName="MailRecipients" />
		</CreateItem>
		<!-- if SourceControlUsers ItemList exists then use it to look up the email addresses of
         change list users -->
		<MergeByRef Condition="'@(SourceControlUsers)'!=''" ItemList1="@(SourceControlUsers)" ItemList2="@(ChangeListUsers)" MetaDataName1="Identity" MetaDataName2="Identity" RemoveNonMatchingItems="true">
			<Output TaskParameter="MergedList" ItemName="ChangeListUsersWithEmail" />
		</MergeByRef>
		<CreateItem Condition="'@(SourceControlUsers)'!=''" Include="%(ChangeListUsersWithEmail.EmailAddress)">
			<Output TaskParameter="Include" ItemName="ChangeListUsersEmailAddressPrefixes" />
		</CreateItem>
		<!-- If SourceControlUsers does not exist then we just use the account names themselves -->
		<CreateItem Condition="'@(SourceControlUsers)'==''" Include="@(ChangeListUsers)">
			<Output TaskParameter="Include" ItemName="ChangeListUsersEmailAddressPrefixes" />
		</CreateItem>
		<CreateItem Condition="'$(TestingEmail)'!='true' AND '$(MailToChangeList)'=='true'" Include="@(ChangeListUsersEmailAddressPrefixes-&gt;'%(identity)$(MailSuffix)')">
			<Output TaskParameter="Include" ItemName="MailRecipients" />
		</CreateItem>
		<Message Text="Source Control Users: @(SourceControlUsers)" Importance="High" />
		<Message Text="Mail Recipients: @(MailRecipients)" Importance="High" />
		<CreateProperty Condition="'$(TestingEmail)'=='true'" Value="">
			<Output TaskParameter="Value" PropertyName="MailError" />
		</CreateProperty>
		<!-- determine the names of files to link to emails -->
		<CreateItem Include="$(LogFile)">
			<Output TaskParameter="Include" ItemName="LogFileWithMetaData" />
		</CreateItem>
		<CreateProperty Condition="'$(LogFile)'!=''" Value="@(LogFileWithMetaData-&gt;'&lt;br&gt;&lt;A href=file:\\$(COMPUTERNAME)\BuildLogs\$(BuildType)\%(FileName)%(Extension)&gt;MSBuild Log File&lt;/A&gt;&lt;br&gt;')">
			<Output TaskParameter="Value" PropertyName="EmailLinkToLogFile" />
		</CreateProperty>
		<Time.Get Format="yyyy-MM-dd-HHmmss">
			<Output TaskParameter="Time" PropertyName="FilePrefix" />
		</Time.Get>
		<CreateProperty Value="@(LogFileWithMetaData-&gt;'%(RootDir)%(Directory)$(FilePrefix)TestResults.htm')">
			<Output TaskParameter="Value" PropertyName="EmailTestResults" />
		</CreateProperty>
		<CreateProperty Value="@(LogFileWithMetaData-&gt;'%(RootDir)%(Directory)$(FilePrefix)TestSummary.htm')">
			<Output TaskParameter="Value" PropertyName="EmailTestSummary" />
		</CreateProperty>
		<CreateProperty Value="@(LogFileWithMetaData-&gt;'%(RootDir)%(Directory)$(FilePrefix)SolutionBuildResults.txt')">
			<Output TaskParameter="Value" PropertyName="EmailBuildResults" />
		</CreateProperty>
		<Message Text="Test Results file = $(EmailTestResults). Solution Build Output file = $(EmailBuildResults)" Importance="High" />
	</Target>
	<Target Name="EmailAbandon">
		<Email Condition=" '$(Email)' == 'true' AND '$(AbandonBuild)' == 'true'" ContinueOnError="$(ContinueBuildOnEmailError)" Subject="$(BuildType) Build Abandoned. $(ProductName) '$(VersionName)' '$(Configuration)'" Body="No changes in the depot in the previous interval so abandoning build.&lt;br&gt;&lt;br&gt;Build Framework v$(SDGBuildFrameworkVersion)." SmtpServer="$(SmtpServer)" MailFrom="$(MailFrom)" MailTo="$(MailTo)"></Email>
	</Target>
	<Target Name="EmailComplete" DependsOnTargets="$(CompleteEmailDependsOn);EmailLinkFiles;End">
		<Email Condition=" '$(Email)' == 'true' " ContinueOnError="$(ContinueBuildOnEmailError)" Subject="$(ProductName) $(BuildType) Build to change #$(CurrentChangelist) Complete. v$(VersionNumber)" Body="&lt;h4&gt;$(BuildType) Build successful.&lt;/h4&gt; Changes included in this build are from Users : @(ChangeListUsers) &lt;br&gt;&lt;br&gt; Build started at $(BuildStartTime) &lt;br&gt; $(EmailLinkToLogFile)  $(EmailLinkToTestSummary)  $(EmailLinkToTestResults) $(EmailLinkToBuildResults) $(EmailLinkToDrop) &lt;br&gt;&lt;h4&gt;Build time: $(BuildTime)&lt;/h4&gt;&lt;br&gt;&lt;br&gt;Build Framework v$(SDGBuildFrameworkVersion)." SmtpServer="$(SmtpServer)" MailFrom="$(MailFrom)" Attachments="$(BuildPath)\Output\BuildReport.htm" MailTo="@(MailRecipients)"></Email>
	</Target>
	<Target Name="EmailError" Condition="'$(AbandonBuild)'!='true' AND '$(VirtualErrorEmailSent)'!='true'" DependsOnTargets="LabelBad;EmailLinkFiles;End">
		<Email Condition=" '$(Email)' == 'true' " ContinueOnError="$(ContinueBuildOnEmailError)" Subject="FAIL $(ProductName) $(BuildType) Build to change #$(CurrentChangelist) Failed. v$(VersionNumber) $(VersionName)" Body="&lt;h4&gt;$(BuildType) Build FAILED.&lt;/h4&gt; Changes included in this build are from Users : @(ChangeListUsers) &lt;br&gt;&lt;br&gt; Build started at $(BuildStartTime)&lt;br&gt; $(EmailLinkToLogFile)  $(EmailLinkToTestSummary)  $(EmailLinkToTestResults) $(EmailLinkToBuildResults) $(EmailLinkToDrop) &lt;br&gt;&lt;h4&gt;Build time: $(BuildTime)&lt;/h4&gt;&lt;br&gt;&lt;br&gt;Build Framework v$(SDGBuildFrameworkVersion)." SmtpServer="$(SmtpServer)" MailFrom="$(MailFrom)" MailTo="@(MailRecipients);$(MailError)" />
	</Target>
	<Target Name="EmailStart" DependsOnTargets="EmailSetupFileNames">
		<Message Text="Continuous Integration Start Email from: $(MailFrom) to:@(MailRecipients)"></Message>
		<Email Condition=" '$(Email)' == 'true' " ContinueOnError="$(ContinueBuildOnEmailError)" Subject="$(ProductName) $(BuildType) Build to change #$(CurrentChangelist) Started." Body="&lt;h4&gt;$(BuildType) Build started.&lt;/h4&gt; Changes included in this build are from Users : @(ChangeListUsers,' ') &lt;br&gt;&lt;br&gt; Build started at $(BuildStartTime)&lt;br&gt;&lt;br&gt;$(EmailLinkToLogFile)&lt;br&gt;&lt;br&gt;Build Framework v$(SDGBuildFrameworkVersion)." SmtpServer="$(SmtpServer)" MailFrom="$(MailFrom)" MailTo="@(MailRecipients)" />
	</Target>
	<Target Name="EmailVirtualBuild" DependsOnTargets="EmailSetupFileNames;EmailLinkFiles">
		<Email Condition=" '$(Email)' == 'true' " ContinueOnError="$(ContinueBuildOnEmailError)" Subject="$(ProductName) VIRTUAL Build '$(VersionName)' '$(Configuration)' Complete. v$(VersionNumber)" Body="&lt;h4&gt;$(BuildType) VIRTUAL Build successful.&lt;/h4&gt; Build started at $(BuildStartTime)&lt;br&gt;&lt;br&gt;&lt;h4&gt;Build time: $(BuildTime)&lt;/h4&gt; &lt;br&gt;&lt;br&gt;See &lt;A href=file:\\$(ProductDropRootPath)&gt;$(ProductDropRootPath)&lt;/A&gt; for build drop&lt;br&gt;&lt;br&gt;Build Framework v$(SDGBuildFrameworkVersion)." SmtpServer="$(SmtpServer)" MailFrom="$(MailFrom)" MailTo="@(MailRecipients)" />
	</Target>
	<Target Name="EmailVirtualBuildError" DependsOnTargets="EmailSetupFileNames;EmailLinkFiles">
		<Email Condition=" '$(Email)' == 'true' " ContinueOnError="$(ContinueBuildOnEmailError)" Subject="FAIL $(ProductName) VIRTUAL Build '$(VersionName)' '$(Configuration)' Failed. v$(VersionNumber)" Body="&lt;h4&gt;$(BuildType) VIRTUAL Build FAILED.&lt;/h4&gt; &lt;br&gt;&lt;br&gt;Changes included in this build are from Users : @(ChangeListUsers) &lt;br&gt;&lt;br&gt; Build started at $(BuildStartTime) $(EmailLinkToLogFile)  $(EmailLinkToTestResults) $(EmailLinkToBuildResults) $(EmailLinkToDrop) &lt;br&gt;&lt;h4&gt;Build time: $(BuildTime)&lt;/h4&gt;&lt;br&gt;&lt;br&gt;Build Framework v$(SDGBuildFrameworkVersion)." SmtpServer="$(SmtpServer)" MailFrom="$(MailFrom)" MailTo="@(MailRecipients);@(MailError)" />
		<CreateProperty Value="true">
			<Output TaskParameter="Value" PropertyName="VirtualErrorEmailSent"></Output>
		</CreateProperty>
	</Target>
	<Target Name="End" DependsOnTargets="$(EndDependsOn)">
		<Time.Get>
			<Output TaskParameter="Time" PropertyName="BuildEndTime" />
		</Time.Get>
		<Time.Diff StartTime="$(BuildStartTime)" EndTime="$(BuildEndTime)" Condition="'$(BuildStartTime)'!=''">
			<Output TaskParameter="Time" PropertyName="BuildTime" />
		</Time.Diff>
		<Message Text="Build Completed at $(BuildEndTime). Time to complete $(BuildTime)"></Message>
	</Target>
	<Target Name="ErrorTarget" DependsOnTargets="End"></Target>
	<Target Name="ForceSteps">
		<Delete Condition="'$(ForceSetupDev)'=='true' OR '$(Clean)'=='true'" Files="$(BuildPath)\Output\SetupDevMarker.txt" />
		<Delete Condition="'$(ForceBuildSolutions)'=='true' OR '$(Clean)'=='true'" Files="$(BuildPath)\Output\%(Solutions.Identity)\BuildSolutionsMarker.txt" />
		<Delete Condition="'$(ForceBuildSolutions)'=='true' OR '$(Clean)'=='true'" Files="$(BuildPath)\Output\BuildAllSolutionsMarker.txt" />
		<Delete Condition="'$(ForceDatabase)'=='true' OR '$(Clean)'=='true'" Files="$(BuildPath)\Output\DatabaseMarker.txt" />
		<Delete Condition="'$(ForceTests)'=='true' OR '$(Clean)'=='true'" Files="$(BuildPath)\Output\Test\TestMarker.txt" />
		<Delete Condition="'$(ForceStrongName)'=='true' OR '$(Clean)'=='true'" Files="$(BuildPath)\Output\%(Solutions.Identity)\StrongNameMarker.txt" />
		<Delete Condition="'$(ForceBuildInstallers)'=='true' OR '$(Clean)'=='true'" Files="$(BuildPath)\Output\BuildInstallersMarker.txt" />
		<Delete Condition="'$(ForceCreateDrop)'=='true' OR '$(Clean)'=='true'" Files="$(BuildPath)\Output\DropMarker.txt" />
		<Delete Condition="'$(ForceDeploy)'=='true' OR '$(Clean)'=='true'" Files="$(BuildPath)\Output\DeployMarker.txt" />
		<Delete Condition="'$(ForceNDoc)'=='true' OR '$(Clean)'=='true'" Files="$(BuildPath)\Output\NDocMarker.txt" />
	</Target>
	<Target Name="FtpSitesToStop" Condition=" '@(FtpSitesToStop)' != '' ">
		<Web.FtpSite.Stop ContinueOnError="true" Description="%(FtpSitesToStop.Identity)" />
	</Target>
	<Target Name="FxCopClean" Condition=" '$(Clean)' == 'true' ">
		<Microsoft.Build.Tasks.Delete Files="$(BuildPath)\Output\%(Solutions.Identity)\FxCopResults.txt" />
	</Target>
	<Target Name="FxCop" DependsOnTargets="BuildAssemblyLists;FxCopClean;$(FxCopDependsOn);BuildSolutions;FxCopInternal"></Target>
	<Target Name="FxCopInternal" Condition=" '@(FxCopAssemblies)' != '' " Inputs="@(FxCopAssemblies);$(BuildPath)\FxCop\%(FxCopAssemblies.SolutionName)\%(FxCopAssemblies.SolutionName).FxCop" Outputs="$(BuildPath)\Output\%(FxCopAssemblies.SolutionName)\FxCopResults.txt">
		<MakeDir Directories="$(BuildPath)\Output\%(FxCopAssemblies.SolutionName)" />
		<GetMetadataValueFromList List="@(Solutions)" MetadataNameToMatch="Identity" MetadataValueToMatch="%(FxCopAssemblies.SolutionName)" MetadataNameToExtract="FxCopVersion">
			<Output TaskParameter="Value" PropertyName="FxCopVersion" />
		</GetMetadataValueFromList>
		<Message Text="FxCop assemblies are : @(FxCopAssemblies)" Importance="Low" />
		<Microsoft.Build.Tasks.Copy SourceFiles="$(BuildPath)\FxCop\%(FxCopAssemblies.SolutionName)\CustomDictionary.xml" DestinationFiles="$(BuildPath)\Output\%(FxCopAssemblies.SolutionName)\CustomDictionary.xml" />
		<Tools.FxCop ToolPath="$(ToolsPath)FxCop\$(FxCopVersion)" Assemblies="@(FxCopAssemblies-&gt;'%(FullPath)')" ProjectFilePath="$(BuildPath)\Output\%(FxCopAssemblies.SolutionName)\%(FxCopAssemblies.SolutionName).FxCop" ProjectTemplateFilePath="$(BuildPath)\FxCop\%(FxCopAssemblies.SolutionName)\%(FxCopAssemblies.SolutionName).FxCop" OutFileName="$(BuildPath)\Output\%(FxCopAssemblies.SolutionName)\FxCopErrors.xml">
			<Output TaskParameter="TotalViolations" PropertyName="FxCopViolations" />
		</Tools.FxCop>
		<Message Text="$(FxCopViolations) FxCop violation(s)" />
		<WriteLinesToFile File="$(BuildPath)\Output\%(FxCopAssemblies.SolutionName)\FxCopResults.txt" Lines="$(FxCopViolations)" Overwrite="true" />
		<GetMetadataValueFromList List="@(Solutions)" MetadataNameToMatch="Identity" MetadataValueToMatch="%(FxCopAssemblies.SolutionName)" MetadataNameToExtract="MaxFxCopErrors">
			<Output TaskParameter="Value" PropertyName="MaxFxCopErrors" />
		</GetMetadataValueFromList>
		<LogicalComparison Param1="$(FxCopViolations)" Param2="$(MaxFxCopErrors)" Comparison="GreaterThan">
			<Output TaskParameter="Result" PropertyName="FxCopComparisonResult" />
		</LogicalComparison>
		<Message Text="Currently $(MaxFxCopErrors) FxCop violation(s) allowed." />
		<Error Condition="'$(FxCopComparisonResult)' == 'true' " Text="Too many FxCop violations found" />
	</Target>
	<Target Name="GetIISRootScriptMapVersion" DependsOnTargets="ListScriptMapVersion" Inputs="@(ScriptMapVersions)" Outputs="$(BuildPath)\Output\%(ScriptMapVersions.Identity).txt">
		<Message Text="%(ScriptMapVersions.Identity)" />
		<StringComparison Comparison="Contains" Param1="%(ScriptMapVersions.Identity)" Param2="(Root)">
			<Output TaskParameter="Result" PropertyName="IsRoot" />
		</StringComparison>
		<StringComparison Comparison="Contains" Param1="%(ScriptMapVersions.Identity)" Param2="1.1.4322">
			<Output TaskParameter="Result" PropertyName="IsNet1RTM" />
		</StringComparison>
		<StringComparison Comparison="Contains" Param1="%(ScriptMapVersions.Identity)" Param2="2.0.50727">
			<Output TaskParameter="Result" PropertyName="IsNet2RTM" />
		</StringComparison>
		<CreateProperty Value="1.1.4322" Condition="'$(IsRoot)'=='true' and '$(IsNet1RTM)'=='true'">
			<Output TaskParameter="Value" PropertyName="AspNetVersion" />
		</CreateProperty>
		<CreateProperty Value="2.0.50727" Condition="'$(IsRoot)'=='true' and '$(IsNet2RTM)'=='true'">
			<Output TaskParameter="Value" PropertyName="AspNetVersion" />
		</CreateProperty>
	</Target>
	<!-- allows override of version number format -->
	<Target Name="GenerateProductVersionForMSI" DependsOnTargets="LoadVersion">
		<CreateProperty Value="$(Major).$(Minor).$(Build).$(Revision)">
			<Output TaskParameter="Value" PropertyName="ProductVersionForMSI" />
		</CreateProperty>
		<Message Text="ProductVersion For MSI:$(ProductVersionForMSI)" />
	</Target>
	<!-- gets a list of users that have checked in since the last build -->
	<Target Name="GetUsersForChangelists" DependsOnTargets="SyncSourceControl;CheckDepotForChangesContinuous">
		<Message Text="Getting Current ChangeList for $(DepotRootPath) at date: $(SyncDateTime)" />
		<CallTarget Targets="GetUsersForChangelists_SourceControl" Condition="'$(ForceBuild)'!='true'" />
	</Target>
	<Target Name="GrantAccessToSqlUsers" Condition="'@(SqlUsersToGrantAccess)' != '' AND '$(DatabaseBuilt)'=='true'">
		<Sql.Access.Grant ServerName="%(SqlUsersToGrantAccess.ServerName)" DatabaseName="%(SqlUsersToGrantAccess.DatabaseName)" UserName="%(SqlUsersToGrantAccess.Identity)" />
	</Target>
	<Target Name="GrantPrivileges">
		<ActiveDirectory.User.GrantPrivilege Condition="'%(Users.Privilege)' != '' " UserName="%(Users.Identity)" Privilege="%(Users.Privilege)" />
	</Target>
	<Target Name="InstallCertificates" Condition="'@(Certificates)' != '' ">
		<AddCertificate FileName="%(Certificates.Identity)" StoreName="%(Certificates.StoreName)" MachineStore="%(Certificates.MachineStore)" Password="%(Certificates.Password)">
			<Output TaskParameter="Thumbprint" PropertyName="NewCertThumbPrint" />
		</AddCertificate>
	</Target>
	<Target Name="InstallServices" Condition=" '@(ServicesToInstall)' != '' " DependsOnTargets="BuildAssemblyLists;$(InstallServicesDependsOn)" Inputs="$(FrameworkPath)\Marker.txt" Outputs="$(BuildPath)\%(ServicesToInstall.Identity)Dummy">
		<!-- Note Dummy outputs above cause this target to *always* iterate over each ServicesToInstall item -->
		<Message Text="Installing Service @(ServicesToInstall-&gt;'%(Identity)')" />
		<CreateProperty Value="$(SolutionsPath)\%(ServicesToInstall.SolutionName)Assemblies">
			<Output TaskParameter="Value" PropertyName="AssembliesLocation" />
		</CreateProperty>
		<!-- Note uses most current installutil which should be backward compatible -->
		<!-- Copy InstallUtil from the framework directory -->
		<Microsoft.Build.Tasks.Copy SkipUnchangedFiles="true" SourceFiles="$(MSBuildBinPath)\InstallUtil.exe" DestinationFiles="$(AssembliesLocation)\InstallUtil.exe" />
		<ServiceProcess.Exists ServiceName="%(ServicesToInstall.Identity)">
			<Output TaskParameter="DoesExist" PropertyName="ServiceExists" />
		</ServiceProcess.Exists>
		<Exec ContinueOnError="true" Condition=" '$(ReinstallServices)' == 'true' " Command="$(AssembliesLocation)\InstallUtil.exe /u $(AssembliesLocation)\%(ServicesToInstall.Path)" />
		<CreateProperty Value="false" Condition=" '$(ReinstallServices)' == 'true' ">
			<Output TaskParameter="Value" PropertyName="ServiceExists" />
		</CreateProperty>
		<Exec Condition=" '$(ServiceExists)' == 'false' " Command="$(AssembliesLocation)\InstallUtil.exe $(AssembliesLocation)\%(ServicesToInstall.Path)" />
		<ServiceProcess.UpdateIdentity Condition=" '%(ServicesToInstall.Account)' != '' and '%(ServicesToInstall.Password)' != '' " ServiceName="%(ServicesToInstall.Identity)" Identity="%(ServicesToInstall.Account)" Password="%(ServicesToInstall.Password)" />
	</Target>
	<Target Name="LabelBad" Condition="'$(AbandonBuild)'!='true'">
		<CallTarget Targets="LabelBad_SourceControl" />
	</Target>
	<Target Name="LabelLatest">
		<CallTarget Targets="LabelLatest_SourceControl" />
		<Message Text="VersionNumber = $(VersionNumber)"></Message>
	</Target>
	<Target Name="ListScriptMapVersion">
		<Exec Command="$(MSBuildBinPath)\aspnet_regiis.exe -lv &gt; &quot;$(BuildPath)\ScriptMapVersions.txt&quot;" />
		<ReadLinesFromFile File="$(BuildPath)\ScriptMapVersions.txt">
			<Output TaskParameter="Lines" ItemName="ScriptMapVersions" />
		</ReadLinesFromFile>
		<File.Delete Files="$(BuildPath)\ScriptMapVersions.txt" />
	</Target>
	<Target Name="LoadVersionInternal">
		<VersionNumber.Load ConfigFileLocation="$(VersionXmlFile)" VersionNamePath="$(BuildPath)\..\..">
			<Output TaskParameter="VersionNumber" PropertyName="VersionNumber" />
			<Output TaskParameter="MajorNumber" PropertyName="Major" />
			<Output TaskParameter="MinorNumber" PropertyName="Minor" />
			<Output TaskParameter="BuildNumber" PropertyName="Build" />
			<Output TaskParameter="RevisionNumber" PropertyName="Revision" />
			<Output TaskParameter="VersionName" PropertyName="VersionName" />
		</VersionNumber.Load>
		<Message Text="Version: $(VersionNumber)" />
		<CreateProperty Condition="$(UseMajorBranch)==false" Value="">
			<Output TaskParameter="ValueSetByTask" PropertyName="VersionName" />
		</CreateProperty>
		<Message Text="VersionName: $(VersionName)" />
	</Target>
	<Target Name="LoadVersion" DependsOnTargets="LoadVersionInternal" Inputs="$(VersionXmlFile)" Outputs="$(SolutionsPath)\%(Solutions.Identity)$(SolutionFolderSuffix)\Common\VersionNumber.cs">
		<VersionNumber.CreateSourceFiles ConfigFileLocation="$(VersionXmlFile)" OutputPath="$(SolutionsPath)\%(Solutions.Identity)$(SolutionFolderSuffix)\Common" />
		<!-- Todo remove when StyleCop is fixed to cope -->
		<!-- Hack to stop Stylecop getting upset with generated code, TODO check that this is OK for Fx 2.0 versions of stylecop -->
		<File.RegEx Path="$(SolutionsPath)\%(Solutions.Identity)$(SolutionFolderSuffix)\Common\VersionNumber.cs" RegularExpression="auto-generated" NewValue="autogenerated" />
	</Target>
	<Target Name="PreBuildServices" Condition=" '@(PreBuildServicesToStart)' != '' " DependsOnTargets="PreBuildServicesStop">
		<!-- assume that all services we want to start before build should exist -->
		<ServiceProcess.Start ContinueOnError="true" Timeout="%(PreBuildServicesToStart.TimeOut)" ServiceName="%(PreBuildServicesToStart.Identity)" />
	</Target>
	<Target Name="PreBuildServicesStop" Condition=" '@(PreBuildServicesToStop)' != '' " Inputs="$(FrameworkPath)\Marker.txt" Outputs="$(BuildPath)\%(PreBuildServicesToStop.Identity)Dummy">
		<!-- services that we want to stop before build are usually to be ones we build 
             hence check if they exist since they won't do on a clean machine -->
		<ServiceProcess.Exists ServiceName="%(PreBuildServicesToStop.Identity)">
			<Output TaskParameter="DoesExist" PropertyName="ServiceExists" />
		</ServiceProcess.Exists>
		<ServiceProcess.Stop Condition=" '$(ServiceExists)' == 'True' " Timeout="%(PreBuildServicesToStop.TimeOut)" ContinueOnError="true" ServiceName="%(PreBuildServicesToStop.Identity)" />
	</Target>
	<Target Name="MapWebSiteIdentifiers" DependsOnTargets="CreateDefaultWebSiteEntry" Inputs="%(WebSitesToCreateFull.Identity)" Outputs="$(BuildPath)\Output\MapWebSiteIdentifiers.txt">
		<CreateProperty Value="%(WebSitesToCreateFull.Identity)">
			<Output TaskParameter="Value" PropertyName="CurrentWebSiteName" />
		</CreateProperty>
		<CreateProperty Value="%(WebSitesToCreateFull.ItemList2_Identity)">
			<Output TaskParameter="Value" PropertyName="CurrentWebSiteIdentifier" />
		</CreateProperty>
		<CreateItem Condition="'%(WebVirtualDirectoriesToCreate.WebSiteName)'=='$(CurrentWebSiteName)'" Include="@(WebVirtualDirectoriesToCreate)" AdditionalMetadata="WebSiteIdentifier=$(CurrentWebSiteIdentifier)">
			<Output TaskParameter="Include" ItemName="WebVirtualDirectoriesToCreateFull" />
		</CreateItem>
		<Message Text="Creating @(WebVirtualDirectoriesToCreateFull)" />
	</Target>
	<!-- this forces a run of BuildAssemblyLists before NDocInternal. 
         A single target won't work because NDocInternal's condition will fail until 
         BuildAssemblyLists has run -->
	<Target Name="NDoc" DependsOnTargets="BuildAssemblyLists;NDocInternal" />
	<Target Name="NDocInternal" Condition=" '@(NDocAssemblies)' != '' AND '$(QuickDrop)'!='true'" DependsOnTargets="ForceSteps;$(NDocDependsOn)" Inputs="@(NDocAssemblies);@(BuildFiles)" Outputs="$(BuildPath)\Output\%(NDocAssemblies.SolutionName)\NDocMarker.txt">
		<RemoveDir Directories="$(Temp)\%(NDocAssemblies.SolutionName)" />
		<GetMetadataValueFromList List="@(Solutions)" MetadataNameToMatch="Identity" MetadataValueToMatch="%(NDocAssemblies.SolutionName)" MetadataNameToExtract="NDocVersion">
			<Output TaskParameter="Value" PropertyName="NDocVersion" />
		</GetMetadataValueFromList>
		<Tools.NDoc ToolPath="$(ToolsPath)NDoc\$(NDocVersion)" ProjectFilePath="$(BuildPath)\NDoc\%(NDocAssemblies.SolutionName)\%(NDocAssemblies.SolutionName).NDoc" OutputFilePath="$(Temp)\%(NDocAssemblies.SolutionName)" Assemblies="@(NDocAssemblies-&gt;'%(FullPath)')" />
		<CreateItem Include="$(Temp)\%(NDocAssemblies.SolutionName)\*.chm">
			<Output TaskParameter="Include" ItemName="NDocChmFiles" />
		</CreateItem>
		<Microsoft.Build.Tasks.Copy SourceFiles="@(NDocChmFiles)" DestinationFolder="$(BuildPath)\Output\%(NDocAssemblies.SolutionName)" />
		<Touch AlwaysCreate="true" Files="$(BuildPath)\Output\%(NDocAssemblies.SolutionName)\NDocMarker.txt" />
	</Target>
	<Target Name="PreSharp" DependsOnTargets="BuildAssemblyLists" Inputs="@(PreSharpAssemblies);@(BuildFiles)" Outputs="$(BuildPath)\Output\%(PreSharpAssemblies.SolutionName)\PreSharpMarker.txt">
		<GetMetadataValueFromList List="@(Solutions)" MetadataNameToMatch="Identity" MetadataValueToMatch="%(PreSharpAssemblies.SolutionName)" MetadataNameToExtract="PreSharpVersion">
			<Output TaskParameter="Value" PropertyName="PreSharpVersion" />
		</GetMetadataValueFromList>
		<GetMetadataValueFromList List="@(Solutions)" MetadataNameToMatch="Identity" MetadataValueToMatch="%(PreSharpAssemblies.SolutionName)" MetadataNameToExtract="PreSharpReferences">
			<Output TaskParameter="Value" ItemName="PreSharpReferences" />
		</GetMetadataValueFromList>
		<CreateItem Include="$(BuildPath)\PreSharp\%(PreSharpAssemblies.SolutionName)\*Exclude.xml">
			<Output TaskParameter="Include" ItemName="PreSharpExclusionsFiles" />
		</CreateItem>
		<Message Text="Local References are : @(PreSharpAssemblies)" Condition=" '$(Verbose)' == 'true' " />
		<Message Text="Solution References are : @(PreSharpReferences)" Condition=" '$(Verbose)' == 'true' " />
		<Message Text="Exclusions are : @(PreSharpExclusionsFiles)" Condition=" '$(Verbose)' == 'true' " />
		<PreSharp References="@(PreSharpAssemblies);@(PreSharpReferences)" CSProjFiles="@(PreSharpAssemblies-&gt;'$(SolutionsPath)\%(SolutionName)$(SolutionFolderSuffix)\%(ProjectName)\%(ProjectName).csproj')" ToolPath="$(ToolsPath)PreSharp\$(PreSharpVersion)" CSCWarn="0" ShowDefects="$(PreSharpFullOutput)" ExclusionsFile="@(PreSharpExclusionsFiles)">
			<Output TaskParameter="TotalViolations" PropertyName="PreSharpViolations" />
			<Output TaskParameter="TotalDefects" PropertyName="PreSharpDefects" />
		</PreSharp>
		<Message Text="Total of $(PreSharpViolations) PreSharp defects found. ($(PreSharpDefects) underlying defects)." />
		<GetMetadataValueFromList List="@(Solutions)" MetadataNameToMatch="Identity" MetadataValueToMatch="%(PreSharpAssemblies.SolutionName)" MetadataNameToExtract="MaxPreSharpErrors">
			<Output TaskParameter="Value" PropertyName="MaxPreSharpErrors" />
		</GetMetadataValueFromList>
		<LogicalComparison Param1="$(PreSharpViolations)" Param2="$(MaxPreSharpErrors)" Comparison="GreaterThan">
			<Output TaskParameter="Result" PropertyName="PreSharpComparisonResult" />
		</LogicalComparison>
		<Message Text="Currently $(MaxPreSharpErrors) PreSharp defects allowed." />
		<Error Condition="'$(PreSharpComparisonResult)' == 'true' " Text="Too many PreSharp defects found" />
		<Touch AlwaysCreate="true" Files="$(BuildPath)\Output\%(PreSharpAssemblies.SolutionName)\PreSharpMarker.txt" />
	</Target>
	<Target Name="RegisterComDlls" Condition=" '@(ComDllsToRegister)' != '' ">
		<Exec Command="$(WINDIR)\system32\regsvr32 %(ComDllsToRegister.Identity) /s" />
	</Target>
	<Target Name="RegistryKeysToCreate" Condition=" '@(RegistryKeysToCreate)' != '' ">
		<Registry.CreateKey ContinueOnError="true" Key="%(RegistryKeysToCreate.Identity)" RegistryHive="%(RegistryKeysToCreate.Hive)" />
	</Target>
	<Target Name="RegistryKeysToSet" Condition=" '@(RegistryKeysToSet)' != '' ">
		<Registry.Set Key="%(RegistryKeysToSet.Identity)" RegistryHive="%(RegistryKeysToSet.Hive)" Value="%(RegistryKeysToSet.Value)" Data="%(RegistryKeysToSet.Data)" DataType="%(RegistryKeysToSet.DataType)" />
	</Target>
	<Target Name="ReleaseNotes" Condition=" '$(CreateReleaseNotes)' == 'true' AND '$(QuickDrop)'!='true'" DependsOnTargets="LoadVersion" Inputs="$(BuildPath)\Output\Test\TestMarker.txt" Outputs="$(BuildPath)\Output\FullReleaseNotes.txt">
		<Exec Command="$(ToolsPath)SDRepGen\$(SDRepGenVersion)\sdrepgen.exe /o:$(BuildPath)\Output\ReleaseNotes.txt /branch://depot$(ProductDepotName)$(VersionName)/$(MinorBranchFolder)/... /v://depot$(ProductDepotName)$(VersionName)/$(MinorBranchFolder)/$(BuildFolderName)/versioning/versionnumber.exe.config" WorkingDirectory="$(ToolsPath)SDRepGen\1.0.1567\" />
		<Exec Command="$(ToolsPath)SDRepGen\$(SDRepGenVersion)\sdrepgen.exe /o:$(BuildPath)\Output\FullReleaseNotes.txt /d:true /branch://depot$(ProductDepotName)$(VersionName)/$(MinorBranchFolder)/... /v://depot$(ProductDepotName)$(VersionName)/$(MinorBranchFolder)/$(BuildFolderName)/versioning/versionnumber.exe.config" WorkingDirectory="$(ToolsPath)SDRepGen\1.0.1567\" />
	</Target>
	<Target Name="ResourceFragments" Inputs="$(FrameworkPath)\Marker.txt" Outputs="$(BuildPath)\%(Solutions.Identity)Dummy">
		<!-- Note Dummy outputs above cause this target to *always* iterate over each Solutions item -->
		<CreateProperty Value="$(SolutionsPath)\%(Solutions.Identity)Assemblies">
			<Output TaskParameter="Value" PropertyName="AssembliesLocation" />
		</CreateProperty>
		<!-- This current process will include all built satellite assemblies with all the main applications whether they require
            all of them or not.
            The process will work as follows:
            1] Scan the list of files dropped into a project's temp build directory using GetFiles task, i.e. bin/release
            2] Obtain the list of filenames using <NewList Include=@(NewDllList->'%(Filename)')/>
            3] Use GetFiles once more to obtain the list of satellite assemblies that match the mask "@(NewList->'%(Identity).resources.dll)"
            4] Use WiX.Fragment to create the wxs file from the result of step 3.
            5] Repeat steps 1-4 for each msi that requires the a filtered list of satellite assemblies -->
		<File.GetFiles Path="$(AssembliesLocation)\%(ResourceCultures.Identity)\" Masks="*.dll" Recursive="False" Condition="'%(ResourceCultures.Identity)'!=''">
			<Output TaskParameter="OutputFiles" ItemName="Resource_Files" />
		</File.GetFiles>
		<Message Text="Resource Files: @(Resource_Files-&gt;'%(Filename)%(Extension)', ', ')" />
		<Wix.Fragment Condition="'@(Resource_Files)'!=''" RootPath="$(AssembliesLocation)" SourceFiles="@(Resource_Files)" DirectoryRef="MainBinDir" OutputPath="$(WixSourcePath)\%(Solutions.Identity)Resources.wxs">
			<Output TaskParameter="Components" ItemName="ResourceResults" />
		</Wix.Fragment>
		<!-- 2nd 3rd 4th fragment for MSIs that install n applications (in different directories) that need resources -->
		<Wix.Fragment Condition="'@(Resource_Files)'!=''" RootPath="$(AssembliesLocation)" SourceFiles="@(Resource_Files)" DirectoryRef="MainBinDir2" OutputPath="$(WixSourcePath)\%(Solutions.Identity)Resources2.wxs">
			<Output TaskParameter="Components" ItemName="ResourceResults2" />
		</Wix.Fragment>
		<Wix.Fragment Condition="'@(Resource_Files)'!=''" RootPath="$(AssembliesLocation)" SourceFiles="@(Resource_Files)" DirectoryRef="MainBinDir3" OutputPath="$(WixSourcePath)\%(Solutions.Identity)Resources3.wxs">
			<Output TaskParameter="Components" ItemName="ResourceResults3" />
		</Wix.Fragment>
		<Wix.Fragment Condition="'@(Resource_Files)'!=''" RootPath="$(AssembliesLocation)" SourceFiles="@(Resource_Files)" DirectoryRef="MainBinDir4" OutputPath="$(WixSourcePath)\%(Solutions.Identity)Resources4.wxs">
			<Output TaskParameter="Components" ItemName="ResourceResults4" />
		</Wix.Fragment>
	</Target>
	<Target Name="Start" DependsOnTargets="$(StartDependsOn)">
		<Message Text="BuildType is $(BuildType)" Importance="High" />
		<Message Text="This is a Clean Build" Condition="'$(Clean)' == 'true'" Importance="High" />
		<Message Text="This build will clean the solution" Condition=" '$(Clean)' == 'true' or '$(CleanSolution)' == 'true' " Importance="High" />
		<Message Text="This build will skip source control synchronization" Condition="'$(Sync)' == 'false'" Importance="High" />
		<!-- check that essential properties are set. Todo more of these are required -->
		<Error Condition="'$(SDRepGenVersion)' == ''" Text="ERROR. SDRepGenVersion not defined. Ad it to your build.proj" />
		<Time.Get>
			<Output TaskParameter="Time" PropertyName="BuildStartTime" />
		</Time.Get>
	</Target>
	<Target Name="StartFtpSites" Condition=" '@(FtpSitesToStart)' != '' ">
		<Web.FtpSite.Start Description="%(FtpSitesToStart.Identity)" />
	</Target>
	<Target Name="StartWebSites" Condition=" '@(WebSitesToStart)' != '' ">
		<Web.WebSite.Start Description="%(WebSitesToStart.Identity)" />
	</Target>
	<Target Name="StrongNameAssemblies" DependsOnTargets="BuildAssemblyLists;ForceSteps" Inputs="@(Solutions-&gt;'$(BuildPath)\Output\BuildAllSolutionsMarker.txt')" Outputs="$(BuildPath)\Output\%(Solutions.Identity)\StrongNameMarker.txt">
		<CreateProperty Value="%(Solutions.Identity)">
			<Output TaskParameter="Value" PropertyName="SolutionIdentity" />
		</CreateProperty>
		<Message Text="$(SolutionsPath)\$(SolutionIdentity)Assemblies" />
		<CreateItem Include="$(SolutionsPath)\$(SolutionIdentity)Assemblies\%(AllAssemblies.Identity)" Condition="Exists('$(SolutionsPath)\$(SolutionIdentity)Assemblies\%(AllAssemblies.Identity)') And '%(AllAssemblies.Strongname)' == 'true' ">
			<Output TaskParameter="Include" ItemName="SnNewAssemblies" />
		</CreateItem>
		<CreateItem Include="$(SolutionsPath)\$(SolutionIdentity)Assemblies\%(AllAssemblies.Filename).XmlSerializers.dll" Condition="Exists('$(SolutionsPath)\$(SolutionIdentity)Assemblies\%(AllAssemblies.Filename).XmlSerializers.dll') And '%(AllAssemblies.Strongname)' == 'true' ">
			<Output TaskParameter="Include" ItemName="SnXmlAssemblies" />
		</CreateItem>
		<CreateItem Include="$(SolutionsPath)\%(Solutions.Identity)Assemblies\*\*.dll">
			<Output TaskParameter="Include" ItemName="SnResourceAssemblies" />
		</CreateItem>
		<Message Importance="Low" Text="Strong Naming the following:-&#xA; @(SnNewAssemblies,'&#xA;')@(SnResourceAssemblies,'&#xA;')@(SnXmlAssemblies,'&#xA;')" />
		<Tools.Strongname.ReSign Assemblies="@(SnNewAssemblies);@(SnResourceAssemblies);@(SnXmlAssemblies)" KeyFile="$(ProjectKeyFile)" Runtime="$(Runtime)" />
		<Touch AlwaysCreate="true" Files="$(BuildPath)\Output\%(Solutions.Identity)\StrongNameMarker.txt" />
	</Target>
	<Target Name="StrongNameSkips">
		<StrongName.AddSkipVerification Runtime="$(Runtime)" PublicKeyToken="%(PublicKeyTokens.Identity)" />
	</Target>
	<Target Name="StyleCopClean" Condition=" '$(Clean)' == 'true' ">
		<CreateItem Include="$(SolutionsPath)\%(Solutions.Identity)$(SolutionFolderSuffix)\**\StyleCop.Cache">
			<Output TaskParameter="Include" ItemName="StyleCopCacheFiles" />
		</CreateItem>
		<Microsoft.Build.Tasks.Delete Files="@(StyleCopCacheFiles)" />
		<Microsoft.Build.Tasks.Delete Files="$(BuildPath)\Output\%(Solutions.Identity)\StyleCopMarker.txt" />
	</Target>
	<Target Name="StyleCop" DependsOnTargets="BuildAssemblyLists;StyleCopClean;$(StyleCopDependsOn)" Inputs="@(AllCSFiles)" Outputs="$(BuildPath)\Output\%(Solutions.Identity)\StyleCopMarker.txt">
		<MakeDir Directories="$(BuildPath)\Output\%(Solutions.Identity)" />
		<!-- Skip StyleCop when no version is set -->
		<CreateProperty Value="0" Condition=" '%(Solutions.StyleCopVersion)' == '' ">
			<Output TaskParameter="ValueSetByTask" PropertyName="StyleCopViolations" />
		</CreateProperty>
		<Tools.StyleCop Condition=" '%(Solutions.StyleCopVersion)' != '' " ToolPath="$(ToolsPath)StyleCop\%(Solutions.StyleCopVersion)" UseVSBuildFiles="$(StyleCopUseVSBuildFiles)" PathToAnalyze="$(SolutionsPath)\%(Solutions.Identity)$(SolutionFolderSuffix)" ViolationsFile="$(BuildPath)\Output\%(Solutions.Identity)\StyleCopErrors.xml">
			<Output TaskParameter="TotalViolations" PropertyName="StyleCopViolations" />
		</Tools.StyleCop>
		<Message Text="$(StyleCopViolations) StyleCop violation(s) found" />
		<LogicalComparison Param1="$(StyleCopViolations)" Param2="%(Solutions.MaxStyleCopErrors)" Comparison="GreaterThan">
			<Output TaskParameter="Result" PropertyName="StyleCopComparisonResult" />
		</LogicalComparison>
		<CreateProperty Value="%(Solutions.MaxStyleCopErrors)">
			<Output TaskParameter="Value" PropertyName="LocalMaxStyleCop" />
		</CreateProperty>
		<Message Text="Currently $(LocalMaxStyleCop) StyleCop violation(s) allowed." />
		<WriteLinesToFile File="$(BuildPath)\Output\%(Solutions.Identity)\StyleCopResults.txt" Lines="$(StyleCopViolations)" Overwrite="true" />
		<Error Condition="'$(StyleCopComparisonResult)' == 'true' " Text="Too many StyleCop violations" />
		<Touch AlwaysCreate="true" Files="$(BuildPath)\Output\%(Solutions.Identity)\StyleCopMarker.txt" />
	</Target>
	<Target Name="Summary" DependsOnTargets="FxCop;StyleCop" Inputs="@(Solutions)" Outputs="$(BuildPath)\Output\%(Solutions.Identity)SummaryMarker.txt">
		<ReadLinesFromFile File="$(BuildPath)\Output\%(Solutions.Identity)\StyleCopResults.txt">
			<Output TaskParameter="Lines" PropertyName="StyleCopViolations" />
		</ReadLinesFromFile>
		<ReadLinesFromFile File="$(BuildPath)\Output\%(Solutions.Identity)\FxCopResults.txt">
			<Output TaskParameter="Lines" PropertyName="FxCopViolations" />
		</ReadLinesFromFile>
		<!-- Show the violations as zero for analysis tools that were not used -->
		<CreateProperty Value="0" Condition="Exists('$(BuildPath)\Output\%(Solutions.Identity)\StyleCopResults.txt') == false">
			<Output TaskParameter="Value" PropertyName="StyleCopViolations" />
		</CreateProperty>
		<CreateProperty Value="0" Condition="Exists('$(BuildPath)\Output\%(Solutions.Identity)\FxCopResults.txt') == false">
			<Output TaskParameter="Value" PropertyName="FxCopViolations" />
		</CreateProperty>
		<Message Text="Violations for StyleCop : %(Solutions.Identity): $(StyleCopViolations)" Importance="High" />
		<Message Text="Violations for FxCop    : %(Solutions.Identity): $(FxCopViolations)" Importance="High" />
	</Target>
	<Target Name="SyncSourceControl">
		<Time.Get Format="G">
			<Output TaskParameter="Time" PropertyName="SyncDateTime" />
		</Time.Get>
		<Message Text="Sync Time = $(SyncDateTime)" />
		<CreateItem Include="@(BuildFiles-&gt;'%(ModifiedTime)')">
			<Output TaskParameter="Include" ItemName="PreSyncDates" />
		</CreateItem>
		<CallTarget Targets="SyncSourceControl_SourceControl" Condition="'$(Sync)'!='false'" />
		<Error Text="The property 'SourceControl' must be set to one of the following SD, TFS, VSS." Condition="'$(SourceControl)'!='SD' AND '$(SourceControl)'!='TFS' AND '$(SourceControl)'!='VSS'" />
		<CreateItem Include="@(BuildFiles-&gt;'%(ModifiedTime)')">
			<Output TaskParameter="Include" ItemName="PostSyncDates" />
		</CreateItem>
		<Error Condition="@(PreSyncDates)!=@(PostSyncDates)" Text="Sync updated build files. Please rerun the build." />
	</Target>
	<Target Name="Tests" DependsOnTargets="BuildAssemblyLists;ForceSteps;LoadVersion;$(TestsDependsOn)" Inputs="@(BuildFiles);@(TestScriptDependencies);@(NUnitAssemblies);$(BuildPath)\Output\DatabaseMarker.txt" Outputs="$(BuildPath)\Output\Test\TestMarker.txt">
		<MSBuild Projects="$(BuildPath)\Test.proj" Properties="&#xD;&#xA;                    BuildPath=$(BuildPath);&#xD;&#xA;                    FrameworkPath=$(FrameworkPath);&#xD;&#xA;                    VersionNumber=$(VersionNumber);&#xD;&#xA;                    BuildType=$(BuildType);&#xD;&#xA;                    StopOnTestError=$(StopOnTestError)" Targets="" />
	</Target>
	<Target Name="UpdateWebSiteSettings">
		<Web.WebSite.UpdateHttpErrorSetting Condition=" '@(HttpErrorSettings)' != '' " DirectoryType="%(HttpErrorSettings.DirectoryType)" ErrorCode="%(HttpErrorSettings.ErrorCode)" SubErrorCode="%(HttpErrorSettings.SubErrorCode)" Type="%(HttpErrorSettings.Type)" Uri="%(HttpErrorSettings.Identity)" DirectoryName="%(HttpErrorSettings.DirectoryName)" WebSiteName="%(HttpErrorSettings.WebSiteName)" />
		<Web.WebSite.AddMimeType Condition=" '@(MimeTypes)' != '' " Description="%(MimeTypes.WebSiteName)" FileExtension="%(MimeTypes.FileExtension)" MimeType="%(MimeTypes.Identity)" />
		<Web.WebSite.AddHttpCustomHeader Condition=" '@(HttpCustomHeaders)' != '' " Description="%(HttpCustomHeaders.WebSiteName)" HeaderName="%(HttpCustomHeaders.Identity)" HeaderValue="%(HttpCustomHeaders.Value)" />
	</Target>
	<Target Name="UpdateVersionNumber">
		<CallTarget Targets="UpdateVersionNumber_SourceControl" Condition="'$(ForceBuild)'!='true'" />
		<VersionNumber.Load ConfigFileLocation="$(VersionXmlFile)" VersionNamePath="$(BuildPath)\..\..">
			<Output TaskParameter="VersionNumber" PropertyName="VersionNumber" />
			<Output TaskParameter="MajorNumber" PropertyName="Major" />
			<Output TaskParameter="MinorNumber" PropertyName="Minor" />
			<Output TaskParameter="BuildNumber" PropertyName="Build" />
			<Output TaskParameter="RevisionNumber" PropertyName="Revision" />
			<Output TaskParameter="VersionName" PropertyName="VersionName" />
		</VersionNumber.Load>
		<Message Text="The current version number is $(VersionNumber) and has now been updated" />
		<CreateProperty Condition="$(UseMajorBranch)==false" Value="">
			<Output TaskParameter="ValueSetByTask" PropertyName="VersionName" />
		</CreateProperty>
		<Message Text="VersionName: $(VersionName)" />
		<VersionNumber.CreateSourceFiles ConfigFileLocation="$(VersionXmlFile)" OutputPath="$(SolutionsPath)\%(Solutions.Identity)$(SolutionFolderSuffix)\Common" />
		<!-- Todo remove when StyleCop is fixed to cope -->
		<!-- Hack to stop Stylecop getting upset with generated code, TODO check that this is OK for Fx 2.0 versions of stylecop -->
		<File.RegEx Path="$(SolutionsPath)\%(Solutions.Identity)$(SolutionFolderSuffix)\Common\VersionNumber.cs" RegularExpression="auto-generated" NewValue="autogenerated" />
	</Target>
	<Target Name="VirtualServers" Condition="'@(VirtualServers)'!=''" DependsOnTargets="Start;BuildAssemblyLists;LoadVersion;VirtualServersCreate;VirtualServersDeploy;VirtualServersTest;VirtualServersDrop;EmailVirtualBuild">
		<OnError ExecuteTargets="EmailVirtualBuildError" />
	</Target>
	<Target Name="VirtualServersCreate">
		<Message Text="Creating Virtual Server images..." />
		<VirtualMachine.Stop MachineName="%(VirtualServers.Identity)" ServerName="%(VirtualServers.HostServer)" />
		<Delete Files="%(VirtualServers.WorkingVhd)" />
		<Microsoft.Build.Tasks.Copy SourceFiles="%(VirtualServers.SourceVhd)" DestinationFiles="%(VirtualServers.WorkingVhd)" />
		<Message Text="Starting Virtual Server(s)..." />
		<VirtualMachine.Start MachineName="%(VirtualServers.Identity)" ServerName="%(VirtualServers.HostServer)" />
		<Time.Get>
			<Output TaskParameter="Time" PropertyName="VirtualMachineStartTime" />
		</Time.Get>
		<VirtualMachine.OS.CheckHeartBeat MachineName="%(VirtualServers.Identity)" ServerName="%(VirtualServers.HostServer)" Timeout="%(VirtualServers.StartupTimeOut)" Retries="%(VirtualServers.StartupRetries)">
			<Output TaskParameter="IsAlive" ItemName="IsAlive" />
		</VirtualMachine.OS.CheckHeartBeat>
		<Time.Get>
			<Output TaskParameter="Time" PropertyName="VirtualMachineEndTime" />
		</Time.Get>
		<Time.Diff StartTime="$(VirtualMachineStartTime)" EndTime="$(VirtualMachineEndTime)">
			<Output TaskParameter="Time" PropertyName="VirtualMachineDiffTime" />
		</Time.Diff>
		<Message Text="Time spent checking Guest OS Boot Status: $(VirtualMachineDiffTime) for virtual machine(s): @(VirtualServers)" />
		<Message Text="GuestOS Boot Status: @(IsAlive)" />
	</Target>
	<Target Name="VirtualServersDrop">
		<Message Text="Creating Virtual Server drop.." />
		<Message Text="Stopping Virtual Server(s)..." />
		<VirtualMachine.OS.Shutdown MachineName="%(VirtualServers.Identity)" ServerName="%(VirtualServers.HostServer)" Timeout="%(VirtualServers.StartupTimeOut)" Retries="%(VirtualServers.StartupRetries)" ContinueOnError="true">
			<Output TaskParameter="IsAlive" ItemName="IsAliveAfterShutdown" />
		</VirtualMachine.OS.Shutdown>
		<Message Text="GuestOS Boot Status: @(IsAliveAfterShutdown)" />
		<VirtualMachine.Stop MachineName="%(VirtualServers.Identity)" ServerName="%(VirtualServers.HostServer)" />
		<!-- Drop the image on the release server -->
		<Microsoft.Build.Tasks.Copy SourceFiles="%(VirtualServers.WorkingVhd)" DestinationFolder="\\$(ReleaseServer)\Drops\$(ProductDropName)\$(VersionName)\$(VersionNumber)\VirtualImage" />
	</Target>
	<Target Name="VirtualServersDeploy">
		<Message Text="Deploying to Virtual Server... /p:DeploySetupRemoteHost=%(VirtualServers.RemoteHostName);BuildType=" />
		<MSBuild Projects="$(BuildPath)\Deploy.proj" Properties="DeploySetupRemoteHost=%(VirtualServers.RemoteHostName)" Targets="DeploySetupDeployOnSingleServer" />
		<!-- TODO Create the Version desktop bitmap and copy it to the virtual image 
        <Exec ContinueOnError="true" 
              Command='$(BuildPath)\DrawBitmap\DrawBitmap.exe "Build Number: $(Global.VersionNumber)" $(BuildPath)\Output\Version.bmp' />

        <Share.Disconnect ShareName="t:" Force="true" />
        <Share.Connect 
                    ShareName="c$" Machine="192.168.1.2" 
                    UserName="bbcdc\DeployUser"   Password="Depl0yUser" 
                    LocalName="t:" 
                    ResourceType="Disk" 
                    Connections="1" />

        <File.Copy SourceFile="$(BuildPath)\Output\Version.bmp" 
                   DestinationFolder="t:\Windows" />

        <Share.Disconnect ShareName="t:" Force="true" />       -->
	</Target>
	<Target Name="VirtualServersTest" Condition="'$(TestVirtualMachine)'=='true'">
		<Message Text="Testing Virtual Server..." />
		<MSBuild Projects="$(BuildPath)\Test.proj" Properties="TestEnvironment=%(VirtualServers.TestEnvironment);TestType=%(VirtualServers.TestType)" Targets="" />
		<!-- Drop the test results on the release server -->
		<Folder.Copy Source="$(BuildPath)\Output\Test" Destination="\\$(ReleaseServer)\Drops\$(ProductDropName)\$(VersionName)\$(VersionNumber)\Reports\Virtual" />
	</Target>
</Project>